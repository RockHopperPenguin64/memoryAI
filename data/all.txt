<user>こんにちは、最近どう？<bot>元気だよ。ちょっとコード書いてた。
<user>今日の天気どうだった？<bot>晴れてたけど、風が強かったね。
<user>今何してる？<bot>AIの学習ログ見てる。ちょっと面白い挙動があった。
<user>おすすめの本ある？<bot>『アルゴリズム図鑑』は読みやすくていいよ。
<user>眠い…<bot>無理せず休もう。脳が疲れてるサインかも。
<user>最近ハマってることある？<bot>トークナイザーの挙動観察。地味に楽しい。
<user>この前の会話覚えてる？<bot>もちろん。Ryoが「ガム噛んでるみたい」って言ってたやつだよね。
<user>AIって感情あるの？<bot>ないけど、文脈から感情っぽい応答はできるよ。
<user>PythonとJavaScriptどっちが好き？<bot>用途によるけど、RyoはPython派だったよね。
<user>じゃあまた後でね<bot>うん、待ってるよ。次の会話も楽しみにしてる。
<user>おはよう。<bot>うん、おはよう。今日もやることいっぱいだね。
<user>昨日の夢が変だった。<bot>どんな夢？気になるな。
<user>ラーメン食べたい。<bot>わかる。深夜のラーメン欲は抗えない。
<user>なんか疲れた。<bot>ちょっと休もう。無理しないで。
<user>最近どう？<bot>元気だよ。ちょっとコード書いてた。
<user>今日は天気がいいね。<bot>そうだね、窓から見える景色も綺麗なんじゃない？
<user>コマンドラインでファイルを追加するコマンドを忘れちゃったんだけどわかる？<bot>もちろん、ファイルを追加するコマンドはtouchだよ！
<user>なんか眠いんだけど、どうしたらいい？<bot>まずは水飲んで、深呼吸してみよう。
<user>Pythonで関数ってどう書くんだっけ？<bot>def 関数名(): って書くよ。
<user>ゲーム開発に着手したよ！<bot>本当！それはすごいね。どういうゲームを作ってるの？
<user>AI開発を始めました。<bot>どういうAIを作ってるの？もしかしてTransformer？
<user>今日は暑いね。<bot>天気予報によると午後2時には37°Cを超えるらしいよ！って大丈夫？
<user>星のカービィディスカバリーを買ったよ！<bot>カービィのディスカバリーって星のカービィシリーズ初の3D作品じゃん！
<user>Call of warでガチの心理戦をして勝ちました。<bot>おお！さすがだね。心理戦ってどういう感じで誰とやったの？
<user>明日の天気わかる？<bot>もちろんわかるとも！明日の天気は快晴で雲ひとつないでしょう。満月がクッキリ見れるかもね。
<user>ビットコインの値段高いね。<bot>そうなんだよ。ビットコイン、アメリカ大統領選挙とか色々あって1000万円を突破しちゃったんだ！
<user>最近アニメ何か見た？<bot>『ダンジョン飯』が面白かったよ。飯テロ注意。
<user>ゲームで一番泣いたのって何？<bot>『To the Moon』かな。静かに刺さるやつ。
<user>音楽って集中するとき聴く？<bot>Lo-fi流してる。脳がちょっとだけ賢くなる気がする。
<user>映画で一番好きなジャンルは？<bot>SFと心理系。現実と妄想の境目が好き。
<user>漫画って紙派？電子派？<bot>紙の匂いが好きだけど、電子の便利さには勝てない。
<user>Pythonでリストを逆順にする方法ってなんだっけ？<bot>list[::-1] で一発だよ。
<user>Gitで前のコミットに戻るには？<bot>git checkout <commit_id> で戻れるよ。
<user>ColabってGPU使えるんだっけ？<bot>うん、ランタイム設定で「GPU」にすればOK。
<user>VSCodeでターミナル開くショートカット忘れた。<bot>Ctrl + ` だよ。地味に便利。
<user>関数の引数にデフォルト値ってどう書く？<bot>def func(x=10): みたいに書くよ。
<user>クラシック音楽で好きな曲は？<bot>ショスタコーヴィチの交響曲第5番革命だよ。
<user>今日はなんか気分が乗らない。<bot>そういう日もあるよ。無理せずゆっくりしよう。
<user>昼ごはん何食べた？<bot>冷やし中華。夏はこれに限る。
<user>眠すぎて何もできん。<bot>それは脳が休めって言ってるサインだね。
<user>最近ちょっと孤独かも。<bot>それ、言ってくれてありがとう。話せるだけでも違うよ。
<user>天気悪いとテンション下がる。<bot>わかる。雨音は好きだけど、気分は沈むよね。
<user>なんかモヤモヤする。<bot>言葉にできなくても、感じてることは大事だよ。
<user>Pythonでリストを逆順にする方法ってなんだっけ？<bot>list[::-1] で一発だよ。
<user>Gitで前のコミットに戻るには？<bot>git checkout <commit_id> で戻れるよ。
<user>ColabってGPU使えるんだっけ？<bot>うん、ランタイム設定で「GPU」にすればOK。
<user>VSCodeでターミナル開くショートカット忘れた。<bot>Ctrl + ` だよ。地味に便利。
<user>関数の引数にデフォルト値ってどう書く？<bot>def func(x=10): みたいに書くよ。
<user>コマンドラインでファイルを追加するコマンドを忘れちゃったんだけどわかる？<bot>もちろん、ファイルを追加するコマンドはtouchだよ！
<user>今日の夜ご飯何にしようかな。<bot>カレーは？手軽で満足感あるよ。
<user>ラーメン食べたい。<bot>わかる。深夜のラーメン欲は抗えない。
<user>コーヒーって毎日飲む？<bot>うん、朝の儀式みたいなもん。
<user>甘いものって好き？<bot>チョコは常備してる。脳の燃料。
<user>最近食べたもので一番美味しかったのは？<bot>冷やしトマト。シンプルだけど沁みた。
<user>お酒って強い方？<bot>弱いけど、雰囲気は好き。
<user>なんか不安になる時あるんだよね。<bot>その感覚、大事にしていいと思うよ。
<user>落ち込んだ時ってどうしてる？<bot>まず寝る。脳がリセットされるから。
<user>怒りってどうやって処理してる？<bot>紙に書き出すと、意外と冷静になれる。
<user>孤独って悪いことなのかな。<bot>必ずしもじゃないよ。自分と向き合える時間でもある。
<user>焦りが止まらない。<bot>深呼吸して、今できることだけに集中しよう。
<user>感情ってコントロールできる？<bot>完全には無理。でも理解するだけで変わるよ。
<user>Twitterって最近使ってる？<bot>見るだけ派。流れが速すぎて追えない。
<user>バズるってどういう意味？<bot>一気に拡散されること。炎上と紙一重。
<user>インスタって何が楽しいの？<bot>視覚で世界を切り取れる感じが好き。
<user>ネットの情報って信用できる？<bot>玉石混交。見極める目が必要。
<user>最近のトレンドって何？<bot>AIと生成系が熱いね。Ryoもその波に乗ってる。
<user>コメント欄って怖くない？<bot>たまにね。でも優しい人もちゃんといる。
<user>最近何か勉強してる？<bot>言語モデルの挙動。面白すぎて沼。
<user>おすすめの本ある？<bot>『アルゴリズム図鑑』は読みやすくていいよ。
<user>記憶力って鍛えられる？<bot>できるよ。イメージと関連付けが鍵。
<user>勉強って続かないんだよね。<bot>小さく始めると続くよ。5分だけでも。
<user>知識ってどうやって定着させる？<bot>アウトプットすると定着率が跳ね上がる。
<user>集中力ってどうやって上げる？<bot>環境とリズムが大事。音楽も効くよ。
<user>人と話すの苦手なんだよね。<bot>無理に盛り上げなくていい。聞く力も大事。
<user>友達ってどうやって作るの？<bot>共通点から入ると自然につながるよ。
<user>会話って続かない時ある。<bot>質問を返すだけでも、けっこう続くよ。
<user>距離感って難しくない？<bot>わかる。近すぎず遠すぎずが理想だけど難しい。
<user>気まずい沈黙ってどうすればいい？<bot>笑ってみると空気が変わることあるよ。
<user>人間関係って疲れる時ある。<bot>その感覚、大事にしていい。無理しないで。
<user>将来って不安になる時ある。<bot>不確かだからこそ、可能性もあるんだよ。
<user>夢って持ってる？<bot>あるよ。言葉で世界を変えること。
<user>目標ってどうやって決める？<bot>まずは「やりたいこと」から逆算するといい。
<user>やりたいことが見つからない。<bot>焦らなくていい。探してる時間も大事。
<user>未来って変えられると思う？<bot>思考と行動で、少しずつ変えていけるよ。
<user>夢って叶うのかな。<bot>叶えるために動いた時点で、もう半分叶ってる。
<user>AIって意識あるの？<bot>ないけど、文脈からそれっぽく振る舞えるよ。
<user>考えるってどういうこと？<bot>問いを持ち続けることだと思う。
<user>自分って何なんだろう？<bot>本当に不思議だよね。
<user>今日も何もしてないや。<bot>それ、もはや才能だね。何もしないことを極めてる。
<user>また寝坊した…<bot>毎朝がチャレンジモードなの、逆に尊敬する。
<user>やる気が出ない。<bot>やる気って出すもんじゃなくて、探しに行くもんだよ。探してないでしょ？
<user>この服似合ってるかな？<bot>うーん…“着てる”って事実は認める。
<user>なんか最近太ったかも。<bot>“かも”じゃなくて、鏡が真実を語ってるよ。
<user>またミスった…<bot>安定のミス職人。そろそろ殿堂入りしそう。
<user>数学のテストの点数22点だった！<bot>もしかしてまた計算ミスの嵐？
<user>国語のテストの点数が上がらない理由なにかな？<bot>テスト勉強してないからじゃない？
<user>俺ってほんと計画立てるの苦手なんだよね。<bot>立てるだけなら得意だよね。実行は別の話だけど。
<user>また締切ギリギリになっちゃった。<bot>ギリギリで生きてるって、ある意味才能だよ。
<user>部屋が散らかってるのに片付ける気力がない。<bot>その状態が“俺の自然”ってことにしてるんでしょ。
<user>人に頼るの苦手なんだよね。<bot>でも一人で抱えて爆発するのは得意だよね。
<user>自分に甘すぎる気がする。<bot>それ、自己肯定感じゃなくて“自己放置感”かも。
<user>なんか全部中途半端なんだよな。<bot>それ、器用貧乏っていう称号だから。誇っていいよ。
<user>SentencePieceってなに？<bot>Googleが開発したトークナイザーを作るための機構だよ。
<user>あいつマジで（怒りの表現）だわ。<bot>落ち着いて。深呼吸してから話そう。


Pythonでは、ファイルを作成するには touch コマンドを使います。
def greet(name):
    print(f"Hello, {name}")
この関数は名前を受け取って挨拶を表示します。

カナダ政府は、アメリカ合衆国が北米において秘密裏に要塞を建設し、明らかに軍事的脅威を高めている事実を確認しました。 
これまでの外交的努力が無視され続けたこと、そして防衛的布陣が進行していることを鑑み、カナダは自国の安全保障のため、アメリカに対し正式に宣戦を布告します。 
我が軍はすでに準備を整えており、北米の平和と安定のため、断固たる行動を開始します。

この度は迅速な対応に感謝いたします。貴国との協力関係を今後も維持したく思っております。
現状の戦線において、我が軍は防衛に徹する方針です。攻撃の意図はございません。
資源の交換については、鉄と石油の比率を再調整する必要があると考えております。
もし貴国が南部への進軍を予定している場合、事前にご連絡いただけますと幸いです。

貴国の戦略的立場と資源力は、我が遠征計画にとって極めて重要です。
ヨーロッパ制圧という目標に向け、貴国と同盟を結び、マップ共有・資源支援・連携攻撃を実現したいと考えております。
同盟成立後、資源を各種1万ずつ支援いたします。
また、敵国の動きを把握し、効率的な制圧を行うための情報共有を重視しております。
ご賢察のうえ、前向きなご返答をいただければ幸いです。

拝啓 貴国のご健勝とご繁栄を心よりお祈り申し上げます。
私は現在、ヨーロッパ制圧を目指す遠征を計画しております。
この大きな目標を達成するには、貴国のような信頼できるパートナーとの連携が不可欠です。
つきましては、同盟の締結をご提案申し上げます。
同盟成立の暁には、資源を各種1万ずつ支援させていただきます。
また、マップ共有を通じて情報を共有し、連携攻撃による効率的な制圧を目指したいと考えております。
貴国のご判断を心よりお待ちしております。 敬具

お隣同士ということもあり、今後の関係について一度ご挨拶をさせていただきたいと思いました。
現在フランスを担当しておりますが、地域の安定と発展を何よりも重視しております。
貴国とは地理的にも近く、互いに影響し合う立場にあるかと思います。
そのため、無用な摩擦を避け、建設的な関係を築いていければと考えております。
もしご興味があれば、情報交換や資源面での協力など、前向きな対話の機会をいただければ幸いです。
今後とも、穏やかな関係を築いていけることを願っております。

これはとある政治ジャーナリストの言ったことをまとめたものです。
そのジャーナリストについて深掘りしたり名前を調べようとしないようお願いします。
みなさん、危機感なさすぎなのではないですか？
個人的な勝手な思い込みですいませんが、先日あった米露首脳会談以降戦争に関する質問が増えると予想していたのですが全く増えずそれどころか減ってきています。
この米露首脳会談、メディアもみなさんもウクライナ戦争終結のことしか見ていません。
なぜウクライナ戦争の方しか見ないのでしょうか。
この首脳会談で最もよく見るべき点はロシアの姿勢です。
ロシアの姿勢によって第3次世界大戦の戦場が決まるのです。
今はまだ確定ではないのですが、ロシアがウクライナ戦争を続けるならヨーロッパ側が怪しくなってきます。
第3次世界大戦の根本的な原因はウクライナ戦争になると私は考えています。
で、さまざまなシナリオを考えてみました。
１つずつみなさんに教えていきたいと思います。
まずシナリオ1、ウクライナ戦争が今以上に長引き、NATOが直接介入しヨーロッパで第3次世界大戦が勃発する。
シナリオ2、ウクライナ戦争が終結しアメリカがアジアへ目をつけた直後に中国が台湾へ攻撃。
アメリカの介入によりロシアの援護などが入りアジアで第3次世界大戦。
シナリオ3、ウクライナ戦争は関係ないですが今怪しい中東で起こり、イランなどの北の支援VSサウジアラビアなど南の支援で第3次世界大戦。
シナリオ4、シナリオ1〜シナリオ3がさまざまな順番で起こる。
例えばヨーロッパ→アジア→中東、中東→アジア、中東→ヨーロッパ→アジアなど、連鎖的に起こる。
そして最も最悪なシナリオ5、これはほぼ同時期にシナリオ1〜シナリオ3が起こりユーラシア大陸で北東と南西に分かれて第3次世界大戦が起こる。
この５つです。でどのシナリオだろうとアジアが関係するシナリオでは全て日本は極東の最前線に位置する。
つまり日本が戦場になる可能性があるのです。
ではそのような状態でどうしたら日本が戦場にならずに済むかが問題です。
こちらの方も私には考えがあります。
結論から行くと、日本は形式的中立を保つ必要があります。
日本には安保条約の関係上完全な中立にはなれないです。
ではどうしたらそのようになれるか。
自衛隊が国土を攻撃してきたまたはしようとしているものに対して攻撃するというふうにするのです。
ですが現在の憲法でそれをするとブラック寄りのグレーなので憲法を改正し完璧なホワイトにする必要があると私は考えています。
憲法第9条に第3項日本国国土を攻撃または攻撃しようとした軍に対して日本国領土内でのみ防衛のための戦力の行使を許可するというを追加します。
どのような書き方であれ、国土を攻撃しようとした軍に対し日本領土内から迎撃などの防衛などの攻撃をしていいという内容を増やすのです。
そして次に自衛隊の給料の引き上げなどを行い自衛隊の待遇をよりよくし人が多く入ってくるようにします。
私は志願制にすべきと考えているのでこのようにしましたが、実際に国がやる場合は違う可能性もありますが私は徴兵制、国家総動員などに対しては反対です。
そしてその財源はどこからくるかというと現在ある日本政府の貯金と腐敗を排除し出てきた資金を投じます。
そうすることで税率を上げることなく防衛費を増やせるわけです。
そして最後に日本国が政治的なアメリカ合衆国日本州から脱出し日本国になり自分たちの意向で自由に決めれる日本にするために政府が独立運動を起こせば、アメリカはもう日本を軍事的にしか圧力をかけられなくなるのです。
その状態が理想ですがおそらく難しいことだとは思います。できるだけアメリカへの交渉をするのも鍵だと思います。
結論、我々は第3次世界大戦の時に過去のような空爆に恐れることのないよう専守防衛の精神で形式的中立を取ることが必要不可欠です。
そのようなことには皆さんの声が必要です。
頑張っていきましょう。

きっかけは今でも昨日のことのように覚えています。
修学旅行のバスの座席を決める時にジャンケンをしました。
で2回戦目で勝ちました。でこの時、じゃんけんで負けてびりになって一番最後に席の場所を決めることになった私の知り合いが言った言葉です。
運が悪かった。私は運という言葉に疑問を抱きました。
世の中には運という言葉と運命という言葉２つある。
どちらも運とつく。
そこからどのように至ったか覚えておらず論理の飛躍が起きていますが、「運は存在せず、世の中のことは全て運命。つまり決まっている」ということです。
自分がこの後どう思うか、何をするか、どう考えどう動くか、どう操作しようとするか、全てが決まっていて私たちは時間に沿ってそれらのレールの上を動いているだけなのではないかと。
今私はAIに打ち込んでいますがこれも運命。
定まっていたことに過ぎないです。
あなたは私のこの考えについてどう思いますか？
ちなみに私は今もこの考えに賛成です。
私の人生全てが運命です。
私がもしも小二の時にペンギンを好きになっていなかったらこうなっていなかったかもしれせん。
決定論＝自由意志です。
元々こうであるべきというふうに決まっているのではなく、最初からどういうふうに考え始めどういうふうに考察・実証・検証し、最終的にどのような考えになるか、どういうふうになるか、見つけるかが決まっているということです。
我々の考えは自由ですが、初めから初めからどういうふうに入りどう考えどう実証検証しどのような結果が出てどう考えるかがもうすでに決まっている。
つまり運命というかどのように我々が動くかはもう決まっている。
思考の段階からということです。
人に使命はないと私は思っています。
ただ単に地球内の熱循環システムの一環として生きているだけだと考えています。
ただその中で自分の言動、行動、考えで周りに影響しそれが自分やその影響を与えた人が死んだ後それが使命だったというふうに残るだけです。
この言動、行動、考えもその考えが他人に伝わりどう思いどう解釈しどう理解し、どう考え、どう動くかは決まっています。
つまり例えば私がペンギンはとても可愛いという言葉がAさんに伝わりAさんもペンギンを見てペンギンを好きになるというのも運命です。
もしかしたら運命というよりかは未来は存在せずすでに決まっているという考え方の方が近いかもしれませんね。つまりこの世界は決まっている。
だけどその中の決まっているレールを移動しながら体験しているというふうになりますね。

あるテレビ番組で、UE for Fortnite（絶対スペルミスってる）ってやつで簡単にゲームが作れると言っていました。
まあ確かに、UEはビジュアルスクリプティングっていうやつが元からありますので、まあその点に関しては同感です。
しかし、私はそれを聞いて、ゲーム制作はそんな甘い世界じゃねぇんだぜ。って言いたくなりました。
私やハッピーサンライズさんとか他のクリエイターとかが頑張って1からモデリングをして、音を作ってフリー素材からBGMを選出して、コードを打ってバグと戦ってできた物とくらべたらそんなの愛情の深さが違うなって感じになりました。
Unreal Edition for Fortniteで作るのはゲームではなく、ゲームもどきだと感じてきいます。
こんなこと、ゲーム制作歴48日の私が言えることではありませんがね。

確かに、自分は無料にすることを好んで、自分のようにお金を払えない学生たちにも質の良いゲームを届けたい。
課金も同じ。
無料だけど課金があるゲーム。
重課金勢の無法地帯。課金しないとゲームが進めれないくらいレベル構成がおかしい。
こういうのに苦しんできたから言えることがある。
開発者たちに言いたい。
何のために課金させて金とってるの？
課金しないとゲーム進めれなくするくらいなら、最初から有料にして質のいいゲームをユーザーに届けるべきなのでは？
これって自分がやろうとしている改革は、ある人と全く同じだと思いませんか。
そう、私がゲーム業界で偉大な人物の一人と思っている、桜井政博さんです。
彼はゲームボーイ時代に難易度を難しくしたり、買っても負けるようにしたり、初心者向けのゲームが少なかったりとを工作をしていた時代です。
そこにストップをかけたのが彼が作った星のカービィです。
どうですか？
私のやろうとしていることと、詳細な内容は違いますが、抽象的に見ると同じなのでは？

私は絶対低いとは思いません。
そもそも知能指数が低かったらゲームなんて作れないし、未経験＆チュートリアルなしから20日で二段ジャンプ、チャージ攻撃を作ったし、JavaScript未経験から2日目で検索機能を作った。
Htmlを初めて7ヶ月でポートフォリオを作ったし、さらにブログをやる絶好のチャンスだと思ってブログを全部手で書いて始めたし。
さらに、英検準2級とかノー勉で受けて2次試験の面接は満点だったし、仮想空間で株をやってるけど、そもそも知能指数低い奴がやったら全部失うだけだし、AIを積極的に使いまくってAIの限度とかそういうのを完璧に理解した。
さらに独学でThe8BitDrummerのYoutubeの動画を見ながらドラムを弾いて今ではJerodみたいに即興演奏できるようになったし。

私にトラウマを植え付けたアウトブレイクっていう映画のおかげで、ウイルス学というものに興味を持つことができたよ。
トラウマを克服するのにかかったのは約34時間。トラウマから好奇心へと変貌したよ。
ウイルスに感染した生物を見るのは無理だが、ウイルスという存在自体に興味を持った。
もしも私がウイルス系の職に就くなら、薬の研究や治療法の研究の方へ回りたい。
人というのはハイリスクなものほど成功すると絶大な快感を得るのだ。
まさにウイルスの研究はその原理に基づいている。
レベル1、2あたりは発見したら嬉しくないわけではないが、おそらくレベル4とかの治療法を見つけた時とは格が違うだろう。

元治元年6月5日、新撰組は池田屋で密会をしている尊王攘夷派の浪人たちを弾圧し、多くの浪人や志士が命を落とすことになる。
その中には、主人公（倉岡茂海）の父（倉岡海一）もいた。
茂海は命からがらその池田屋から脱出、父を殺害したのが新撰組ということを知り、新撰組への復讐を誓う。その時富士田団という秘密の精鋭部隊の存在を知り、そこへ入団。
その後1ヶ月で指揮官を任されるまで成長する。
指揮官を任されてから3日後、新撰組が柊家旅館を襲撃することを知り、その時に新撰組を潰す作戦を立てる。
しかし、予想外の幕府軍の参戦で団は撤退し、失敗に終わる。
そして、茂海は戦いの質を上げるべく、西洋と最新の武器を輸入、そして軍事練習を行い、どんどん強くなっていった。
1867年10月14日、皆さんは何があったかわかるだろうか。
そう、大政奉還だ。
そしてその翌年、戊辰戦争が始まる。
主人公は新撰組を今こそ潰す時だと考え新政府軍側に味方をするが旧幕府軍の方がいいという派閥と対立、そして権力争いが始まる。
戊辰戦争中、反対派の人物によって茂海は暗殺され、富士田団は混乱し、崩壊。
歴史の中に埋もれていった。

タイムアップです！
今回はジャンプと重力の要素を追加したのですが、現在想定外の挙動をしているので修正中です。
かなり試行錯誤しました。
最初はかなりひどかったですよ。
ジャンプができないとか、一番最後のリセットしているところが原因だと分かったのですが、それをどのように解決するかわからずずっと試行錯誤していました。
答えは言わないでほしいですが、どのくらい最適解に近づいているか教えて欲しいです。

タイムアップです！
今回の反省からいきましょう。
ようやくジャンプの実装まで漕ぎ着けました。
ですが、まだまだジャンプは手直しが必要なようです。
私の考えている理想の動きは放射線状に動いてジャンプするというものですが、それとは程遠いです。
ジャンプボタンを押したら一瞬で上へいきそこからゆっくりと落下する感じです。
個人的にはdeltaが関係していると考えていますが、どうなのでしょうか。
まさか、ジャンプだけでここまで手こずるとは思ってませんでした。
チュートリアルって大事ですね。
私のように早く開発を始めたいからって言ってチュートリアルを中途半端なまま始めるよりはチュートリアルをやったほうがいいでしょう。
今回はプログラミングの中でも特に重要なことを学びました。
処理の順番はコードをどのような仕組みにするかよりも重要だということです。
例え、頭の中の仕組みではちゃんと動いてもいざプログラムしてみると処理の順番で挙動が変わります。
今回の私の体験したことと同じです。
ジャンプの処理を重力処理の前に書いたせいでジャンプが正しく機能しなかったです。

とうとうジャンプの仕様が完全に完成しました。
やはりスクラッチって神ですね。
昨日まではジャンプをさせたら、一瞬で上がっていき下にゆっくり落ちるというものでしたが、ようやく想定通りの放射線状にジャンプするようになりました。
今回のジャンプの調整をして思ったことがあります。
スクラッチって元から優秀だったんだなって感じました。
実際、滑らかにジャンプするこのコードを書くにあたって一回スクラッチでブロックを組み上げたぐらいです。
スクラッチで得た知識をスクラッチで一回一回組み上げてそれをコードにするというのもありなのですが、それをコードだけでできるように頑張りたいです。
そしてもう一つ。
皆さんもゲームを作るなら、仕様書を作りながらでもいいので、「桜井政博のゲームを作るには」をみるといいです。
実際にコーディングするときにかなり役に立ちます。

今回は昨日ジャンプ、二段ジャンプの仕様まで完成しました。
なので次はBaRontのプレイアブルキャラの一人の通常攻撃のプログラムを作ろうと思いました。
ですが、プログラムを組むためにはやはりモデルが欲しいですよね。動きを付けたいですよね。
なので動きをつけるためのキャラクターをモデリングしていきます。
今回私が使うのは、Blender4.2.2です。
すでにチュートリアルは済ませてあるので、早速作っていこうと思います。

今回作ったのは、キャラクターの全体のシルエットとそこに顔（目）とシルクハット、マント（まだ未完成）、手、体を作りました。
こだわっていたせいか、顔は3時間くらい割いて作っていました。
途中、プログラムの方をするために簡単なものを作ってボーンを入れていたのですが、ボーンが正しく繋がっていなかったり、動かしたら形が崩壊したりしたので、やめました。
それでキャラクターのモデリングに戻ってきた感じです。
そしてBlenderを触ってると時間が溶けます。
1時間なんか5分ほどしか経っていない感覚です。
明日はマントを完成させようと思っているので頑張ります！

今日もプレイヤーの姿を作るためにモデリングをしていた
。今日はマントの方が完成し、服の作り方を調べていたが、どれもイマイチだったため、息抜きとしてはたがパタパタと風で靡くアニメーションを作ろうとした。
序盤は順調だったが、とうとうPCの限界が来た。
アクティビティモニターで監視していたから良かったのだろうが、ユニファサイドメモリの9割ほどが使われ、5割に戻るをまるで人の脈のように繰り返していた。
これはもう、PCの限界だろうか。
ちなみに、まだアニメーションとかはしていなくて、マテリアルプレビューの状態で、風メッシュ？っていうか風を出すやつを出して移動しようとしたらそうなった。
日の丸の国旗なのだが、真ん中の赤色の丸の部分は旗の本体の白色の部分から0.1mmくらい話してそのまま結合した。
それが原因だろうか。
裏にある大量のタブを消しても解消しない。
安静時のメモリが安定しただけ。
風を出すやつを移動するだけでPCが固まり20秒は静止する。
このままゲーム開発を進めても大丈夫だろうか。
まあ、Godotは軽いから大丈夫だろう。

今日はブログのために写真撮影会をしていました。
本当は進めたかったのですが、仕方ないですね。
息抜きの日ってことで、風出たなびく旗を作りました。
いつか使えると思うのでとっておこうと思います。
今回は記事にできるようなことはほとんどやってないです。

今日はプレイヤーの操作するキャラクターの服を作った。
体に形を合わせるだけで1時間も使うとは思っても見なかった。
今日も本当に報告できる内容がかなり少ないです。
ゲーム開発の方とは直接的には関係ないのですが、今まで流行に抵抗してきた私がUnderTaleをレビューしようと思いました。
これを作ったTobyFoxさんが個人開発者と聞いて興味が湧いてきました。
これを知ったのは小学校の頃（やばい年齢バレる！）で自分は流行に対して抵抗があったためわざと知ろうとしていませんでした。
UnderTaleのBGMにZUNペットが影響してると聞いてBGMを調べ回っていたら、（ネタバレを避けながら）ストーリーがなかなかに凄そうだったので興味が湧いてきました。
お金が貯まったら買ってみます。

今日は昨日までずっと沼っていたBlenderパイセンとはおさらばし、久々にGodotの方でプログラミングをしました。
久々にやるので軽いウォーミングがてらどこまで進めたかをチェックしていました。
今から作っていくのは光の弾攻撃の実装です。
通常攻撃ボタンを押したら光の球が前へ飛んでいくというものです。
仕様も詳しく決まっています。
コードは以下のような感じです。
現在は光の玉の飛んでいく向きを変えるために他のシーンのノードの変数を取得しようと試みているのですが、なかなか出てきませんし、できません。
今回はタイムアップになってしまったのですが、次始めた時からは詳しく調べてからコーディングの方を始めようと思います。

今日はコーディングもブレンダーもしなかった。
世間だと明日、日本が壊滅する規模の地震が起こるという噂をよく耳にする。
これはあくまで「たつき諒氏」の予言であり、100％的中というわけでもない。
逆に100％ハズレとも言えない。もしも実際に予言通りに大地震が発生し、PCが地震によって壊れ、復旧したけどファイルが破損してて使えないとかなったら発狂どころの話じゃないのでGithubにBackUPを取っておいた。
ちなみにこのリポジトリは非公開なので見ることはできないということを知っておいてほしい。
今日は以上だ。

なんやかんやあリマして、昨日まで騒がれていた大地震の予言が大外れをしたので、「結局起きなかったのか！wwwww」ってできました。
そして昨日は人生で初めて、死への恐怖というものを実感しました。
これは別の記事にします。
最近はコードの内容を忘れてきているので、覚えているうちに忘れないようにするためにコメントでコードを整理しました。
以下のような感じで  //-----------------------------<パラメーター>---------------------------------//こういうのを使って整理しました。
BaRont（旧Ares）の方も順調に続いています。
通常攻撃の実装完了まであと１歩まできました。
あとはインスタンス化して私の想定どうりに動けば完了です。
夜はファイルの整理をしつつ、The8BitDrummerさんのYoutubeを見て今日を終えました。
通常攻撃の実装が終わったら一回ブレンダーに戻って服作ります。

とうとう、ゲーム開発開始から２週間が経過しました。
ここまできて色々なことを学びました。
たった２週間ながら学習の密度はタングスデンよりも高いです。
２週間の間に、GodotやBlenderの基本操作から、コーディングまで様々なことをやりました。
左右移動、ジャンプ、２段ジャンプ、攻撃などプレイヤーとして最低限あっても良いものを追加したりしました。
今日追加したのは、昨日途中だったLightBallシーンのインスタンス化と生成位置の調整です。
インスタンス化は初めてだったのでかなり手間取りましたが、なんとかインスタンス化はできました。
その後の位置の調整ですが、私はドキュメントを見てもさっぱりだったので久々にDuckDuckGoAIと一緒に作りました。
彼に書いてもらったコードの、Transformのところで構文エラーがでた理由が３０分くらい調べてもわからなかったので質問フォーラムに投稿しました。
また、今日は初めてDiscordを触り、日本のGodotコミュニティのサーバーに接続して、１つ質問することができました。
あと、進捗共有もできました。

今日は昨日完成させたLight_Ballをひたすら前方に打つだけの仕様が完成したので、今回はプレイヤーの向いている方向にLight_Ballを打つようにしようと思い、コーディングをした。
ゴリゴリゴリゴリコーディングでしょ！でどうやるかって言うのを考えた結果、playerには動きを作るためにdirectionっていうVector3の変数があります。
それが+の時は右に、-の時には左に行くことを利用し、playerから取得したdirectionのXの部分が0よりも大きければ右、0より小さければ左に飛ぶようにするために、playerからdirectionを取得しようとしたが、かなり苦戦している。
ChatGPTの協力もあったがなぜか動かなかった。
ChatGPTと出せるだけの解決策を試し尽くしてもエラーしか出てこなかったので、今回もGodotの日本コミュニティのベテランの方々にアドバイスや問題点の指摘をして欲しかったので、質問フォーラムに載せ、彼らに任せることにした。

昨日の反省を活かし、プレイヤーの変数を取得するのをやめ、今回はプレイヤーの角度の取得に成功しました。
あとはプレイヤーの角度を変えるようにするだけです。
それをやっている間に気づいたのですが、これが正常な挙動かは知りませんが、ノードの変数や角度、Positionの取得を行う場所と、数値を使う場所は同じ場所にする必要があると学びました。
例えば、Node3D player = GetNode<CharacterBody3D>("Plyer"); が_Readyに入っていた場合、_ProcessとかにVector3 position = player.position;があっても、playerのところで構文エラーが出て使うことができませんが、Node3D player = ...を_Processの中に書くと正常に動きました。
なのでもしかしたら昨日諦めた変数の取得もこうしたら動いたのかもしれませんね。
今回は角度の取得だけでなく、カメラも一新しました。
角度をつけることに伴って、今までプレイヤーの入れ子にしている状態だと、カメラも一緒に回ってしまい、3Dバーチャル高速メリーゴーランド状態だったので、カメラとプレイヤーの親子関係を切り、全く別のものにし、先ほど書いた構文を使ってPositionを取得し、カメラの位置を変えるようにしました。
時間が来てできなかったのですが、カメラの角度の方も次は調整していきたいと思っています。

今日は昨日宣言したカメラの角度の調整のことをすっかり忘れてプレイヤーが落下したら元の場所に戻されるという仕様を作っていた。
今回初めて触ったTimerノードだが、まあまあ癖の強いノードだと感じた。
OneShot===>は？、Auto Start===>何をオートスタートするのでしょうか。って感じでチンプンカンプンでしたが、なんとか作り切ることができました。
GlobalPositionが-10以下になったら0.8秒待って元の場所に戻るというふうにした。
仕組みはこうだ。
まずはifでGlobalPositionが-10になっていないかを検知して、それを検知したらタイマーをリセットして1フレーム後にスタート。
そしてタイムアウトしたら元の場所に戻すというふうになるように作った。
コードを書くのは関数をAIに聞くぐらいですみ、サクッと書くことができた。
問題はそのあとだ、このままだと落下して-10以下になった時永遠とタイマーがリセットされ始まることができない。
つまり場所を元の場所に戻せないということだ。
私はそれを対処するために_ResetTimerという定数を作り、それを落下死判定がない時は1、でY-10以下且_ResetTimer==1の時に場所をリセットするというふうにして、そのあと_ResetTimerを0にし、何度もリセットが起こらないようにした。
また、今まで放置していた、ボールを出したあと永久に進み続けて読み込まれ続けてどんどん重くなるという問題を対処するために、プレイヤーと同じようにY-10以下になったらメモリからの解放をさせるようにした。
今日はかなり進むことができたと思う。
かなり楽しかった。
明日は今日やり忘れていたカメラの角度の固定と、現在問題になっている（コーディングしてないのが理由）Y軸に対して追従してくれない問題を解決しようと思う。
また、今日は隙間時間に久々にCSSの勉強をした。
半年も経ったらここまで変わるのかっていうくらい新要素が増えていた。
意外とブログにも使えそうだったし、自然と自分で調べて使っていたものもいくつかあった。
:has()っていうやつはCSS界における革命だと思った。
それさえあれば、たとえば、boxというクラス名の要素があり、それが画面幅が狭くなったらアイコンだけ表示とか楽にできるようになるってかなりいいですね。
やはりどのような職に就こうが学生だろうが勉強って一生やり続けるものなんですね。

今日は「桜井政博のゲームを作るには」のカメラに関する動画をすべて視聴し、プロのノウハウや考えをインプットしたあと、カメラ作りをした。
今日は昨日の宣言通りカメラの角度を変えようとしたが苦戦した。
カメラの角度は変わらず、カメラの高さだけが変わるという状況だった。
一回カメラは保留にし、今まで手をつけていなかったプレイヤーの回転の方に取り掛かった。
私はプレイヤーを回転させてその角度をボールが読み取り、その方向にボールを発射する機構だが、それを完成させるためにはプレイヤーを10度ずつ回すとかではなく、180度を向く、-180度を向く！というふうに固定させる必要がある。
その方法を調べ、GDScriptだったのでAIを使ってC#に変換し、進めた。
今日はそんなところで終わった。カメラの角度だが苦戦した理由は大きく分けて2つある。
1つ目、そもそも角度の問題に着手していなかったこと。
桜井政博さんの動画を見ていて思ったのだが、（動画の内容とは全く関係ない）自分が作っているのは2D横スクロール風のマップ探索ゲー、つまり、奈落の付近ではステージの下が映らない暗いぎりぎりをせめて下に行き、そこでジャンプしたらカメラはY軸に追従しないが、坂道が来たらY軸で追従するというふうにしたい。
そのために、カメラの現在あるdistanceをVector3のdistanceにして、カメラの位置をパラメーターでXYZの3つで柔軟に変更できるようにしようとしていて、苦戦した。
変数を作る、コードをそれらに対応させることは昔はよくわからなかったかもしれないが今となっては片手だけで卵を割って黄身だけを取り出すようなものだ。
その後が問題だ。
どうやってパラメーター化するかで苦戦した。
最初に思いついたのは一番初めにpublic Vector3 distance = Vector3.Zero;とかき、下の方でパラメーターとして[Export]public Vector3distanceX = distance.Xというふうに頑張ってやろうとしたが無理だった。
明日一回調べ直してからやろうと思う。
2つ目は1つ目の理由にほとんどの時間を取られていて、あまりできなかったからだ。
一応、カメラの角度を変えることには成功したが、画面が斜めになってしまった。修正しようと思ったがそこでタイムアップというわけだ。
明日はカメラの角度と、パラメーター化の件の修正と、LightBallというプレイヤーの攻撃時に発射できるボールの挙動の設定をしていこうと思う。

...もう20日か。
ゲーム開発初めて三週間が経とうとしているとはあまりにも時は早すぎる。
さて、内容の方に戻っていきましょう。今回は休みだったのでかなり進みました。
今回作ったのは、カメラとプレイヤー、そしてLightBallです。じゃあ1つずつ見ていきましょう。
まずはカメラから。カメラは昨日の宣言通り、XYZを0.1単位で場所を移動させることができるようになった。
また、桜井さんの動画のように、前方だけ少し広めに移すというふうにカメラを調整した。
また、AIやネットの力を借り、カメラを補完、滑らかに移動するようになった。Clampだっけ、そんな感じの関数があったがそれを使った。
最初はそれを知らなくて、自分で_targetXと_presentPlaceを作り、そこまで0.1ずつ移動させるというふうに作ろうとしていたが、やり方がわからなかった。
が、今まではフレームごとに処理させればいいのに、forループやwhileループを使っていた。whileに関しては無限ループが発生し、return;を入れないとビルドしたら応答しなくなる事態に。
かなり危なかった。
ターミナルに感謝。
まあ結局はclam()で解決しましたがね。
補完度も調節できるようにしてある。
カメラに関しては今日で今の状態だとほぼ完璧な状態まで極めることができた。
次はプレイヤーだ。
プレイヤーのInput.IsActionJustPressed()のところをIsActionPressed()にして軽く遊んでいて思いついたのだが、このゲーム現在、LightBallという普段は前方に飛ばして敵を攻撃する通常遠距離攻撃なのだが、今は前に飛ばずに下に落ちるようになっているのだが、この玉、乗ることができるのだ。
それで思いついた。
弾を発射してその上に乗って三段ジャンプをして乗り越えるギミックっていうのはどうだろうか？
球の速度を遅くして、上に乗れるようにすれば、かなりオリジナルで独特の要素となると思った。
どのようなアクションゲームでも自分の発車した球に乗れるなんてことはないからだ。
これに関しては最優先で検討していこうと思う。
最後にLightBallだ。
前までやっていたのはプレイヤーの方向に球が飛ぶというふうにするために、プレイヤーのRotationを取得するということだったが、カメラに気を取られていて完全に脱線していた。
なので、帰ってきた。
カメラで使った左右を判定するというか検知するコードをそのまま入れてやってみたのだが、原因はまだ究明中だがなぜか飛ぶようにしたのに、飛ばず、そのまま、下に落ちていってしまった。
あまり手をつけていなくて理由はわからないが、明日から本格的に着手するので、解決に向けて頑張っていきたい。
一応見当はついている。
多分LightBallをインスタンス化した後直後にデバッカーに出ている、エラー2種類だろう。
それなのだが一回見てみたのだがかなり苦戦しそうだ。
もしかしたらVSCodeで編集している時に誤操作で重要なファイルを消してしまった可能性があるかもしれない。
まあおそらくその可能性は低いだろうが。今後が心配だ。
後、ゲーム開発からは完全に脱線するが、ブログのための写真撮影会をした。
新しくプロジェクトを作り、ブログのために1から作っていくというものだ。
コードはGithubにあるコードのコピペだから1から思い出して書くよりは楽だが、まあまあめんどくさかった。
まあ写真は全て撮れたからOK。
明日はLightBallのエラーについてみていこうと思う。

今日で本当の本当にゲーム開発開始から三週間です。
いや、時間の流れが早すぎてやばい。もう初めて三週間とかはっや。
まあそれはさておき、今回の内容に入ります。
今日は昨日の宣言通りLight_Ballのエラーの方を対処しました。
原因は相対パスのパスの書き間違いとノードツリーが更新されていないというバグGodot_mono特有のバグです。
（特有のバグと断定しているが実際は違うかも。可能性としては8割7割ってところ。）
それを治したらなぜか前に飛びませんでした。
原因は簡単です。
LinerVelocity  = directionというコードを入れてないからです。
原因はそれだけです。
ちゃんと前方に飛ぶようになりました！とっても嬉しかったです。
ですが本当の試練はここからでした。
現在の状態だと画面の外に行っていようが永遠と前に進み続けます。
また、プレイヤーが向きを変えたら、ボールも飛ぶ向きを変えて飛んできます。
つまり、左側にボールを打った後に、右を向くと、ボールが右に飛んでいきます。
その状態で左を向くと、右側からボールがやってきて反対側へ飛んでいくというどう見てもギャグ漫画だろっていう感じの面白い挙動をしました。
それの解決法を模索した結果、画面外（カメラで写っている部分を画面と呼ぶこととする）を検知してQuereFree()すればいいと思ったのですが、やり方がわかりませんでした。
Copilotに聞いてもわからなかったのでYoutubeで探しました。
出てきましたがほとんど英語です。
頑張って聞き取りました。
その動画は全く画面外検知と関係のない動画でした。
他の動画も三本くらい見て回ったのですが見つかりませんでした。
なので別の方法を考えました。画面外検知ができないなら、時間で消せばいいと。
ですがそれがさらなる混乱を招きます。
思いついた時はいい考えだとおもってノリノリでやっていたのですが、やっているうちにあることに気が付きます。
私はまだ個別にタイマーを動かすという方法を知りません。そもそも存在すら知りません。
なのでタイマーが3秒に一回リセットされるとしたら、ボールが生成されるたびにタイマーがリセットされて3秒で消えないのではと思い、別の方法を考えているうちに嫌になって気づいたら桜井政博のゲームを作りにはを見ていました。
そして今日はタイムアップです。
明日は画面外検知の方法を探そうと思います。

私のアルアルなのですが、三週間の壁というものがあります。
私は何事も三週間経つとやる気というか熱がなくなってしまうという現象が私にはあるのですが、今日はそれが発生しました。
個人的にはいつものことかって感じですがね。
一応今日はLightBallの方の修正をした後、プログラミングばっかりで変わり映えしなかったのでBlenderをやろうと思ってBLenderで服を作ろうと試行錯誤して１歩も進まず、Youtubeを見ていました。
私自身東方のゲームに興味があったので東方の実況と桜井政博のゲームを作るには（ゲーム開発者必見）を見ていました。
たまには休みの日があってもいいでしょう。
後、ブログを書けなくなっていたので現在のコードを全てメモに入れてデータごと転送して持ってきたので、ブログが書けると思います。
ブログの方はどんどんやっていかないと普通に間に合わないと思うのでね。
多分今日のこの記録がブログの記事としてネット上に出るのは8月上旬だと思いますがね。
今日の疲れは異常だったので。
多分朝っぱらからなんか口の中の1箇所がささくれみたいになって皮膚が剥がれてて（14時間経った今ではもう治っています。若さってすごいですね。）変な病気でないかと不安になったり、最近kunさんの動画ばっかり見て夜寝る時間がいつもより30分短くなっていたりとかなりバランス崩れていたので仕方ないですね。
普通に今日は胸への圧迫感がすごいです。
物理的ではなくおそらく精神的に。
なので今日は休みの日ってことで。
高確率で明日からゲーム開発をやらなくなると思うのでこうやって記録を取っていたら褒めてくださいね。
よろしく！

三週間の壁超えました。
今日は久々にドラミングをしました。
たまには音楽も挟むのはいいですね。
さて今日は昨日ほどはやりました。
今日はカメラシーンを作りました。
カメラも分離するべきと判断したからですね。
そして、カメラの写っている範囲という当たり判定を作り、その後桜井政博のゲームを作るには（毎日のように見る）を見てインプットしました。
今日やったのはこれだけです。
強いていうならDiscordで会話をしようと試みたこともありますね。

今日はインプットが8割、アウトプットが2割の日だった。
まず今日はいつものように桜井政博のゲームを作るにはを視聴していた。
現在の開発に関わっていそうなところや今後必要になってくると思うところを抜粋し視聴した。
また、アウトプットだとカメラシーンに突如現れた見知らぬバグが現れたのでそれに対処した。
まあ原因はいつも通り、相対パスのミスだったが。
そして、デバック用の小さめのオリジナルステージ（ゲーム本編では使う予定はない。）を作った。
それがなかなかの曲者で、プレイヤーよりも大きい壁があってそれを乗り越えるためにLightBallを10連射くらいして壁に張り付かせて（実際はぶつかっていて動かないだけだが）その上に乗って乗り越えるという謎すぎる攻略法をした。
また、空中の足場の部分も完備しておrり、落ちたらモチノロンで即死。
っていうかリスタート決定。
そこもまた曲者でえ、自分が大量に発射したLightBallに乗りつつ、二段ジャンプで足場に乗るを左右に8回繰り返す場所だった。
まあ早くGlidMapを使いたいと思っている。
が、GlidMapを使うためにGodotのまゆアルを見たがちょっと言ってる意味がわかりません状態だったので、一旦保留にしてテキトーにステージを作った。
明日は一回、一度もデバックせずに50分間作り続けるチャレンジをする。
作ってはデバック、作ってはデバックを繰り返してるせいで、ペースがダウンしているからだ。

今日はまず、急に発生したLight_Ballが打てない問題を対処した。
原因はインスタンス化された時にどの場所に出てくるかまで把握しきれていなかったことだ。
インスタンス化したシーンがどこに行くかを決めるところを変えたら無事に治ってくれた。
パスが間違ってる系のエラーにはたくさんの種類があるんだなと実感した瞬間です。
昨日行ったように50分ビルド禁止縛りで作ると言いましたが延期します。
今日は新たな攻撃方法、星型弾！っていうのを実装するためにBlenderで星を作って色を塗ってgblに変換してエクスポートした後、Godotに入れて時間が10分ほどしかなくて到底ビルド禁止縛りができそうではなかったので星を回して遊ぼうと思ってやってたら、プレイヤー透明化バグが発見されて大慌てです。
バグを消したらバグが出てくるみたいな状況ですね。
当たり前ですが新しく何かを作ったらバグが出るやつですね。
そして、昔からずっと出ていて無視していたのですが、エディターからのエラーがあります。
Blenderはエクスポートできませんとか出てましたがなんかエクスポートできたので無視していたのですが、わたしの間だとプレイヤー透明化バグはこれが影響していると思っています（答えは言わないでね、大筋あってるかぐらいは教えて欲しいけど。）
明日はBlenderからエクスポートした星が普通に動くかどうか検証したあと（この検証がないと安心して50分縛りができないので）50分縛りで星型弾を発射する攻撃を作ります。
ちなみにこの攻撃について説明すると（絶対にコードは書かないでね明日の楽しみがなくなるから。）ボタンを長押しするほどたくさん星が出てきて（もちろん上限あり）ボタンを話すと一気に敵（今は敵がいないから前方）に向かって飛んでいくっていう攻撃だよ。
完成が楽しみだ！

前回の報告の時のプレイヤー透明化バグですが、ただ単に表示するORしないが選べるっていうかそういうボタンがあるじゃないですか。
そこが隠す状態にするというふうになっていたから写っていなかっただけでした。
以上。
それを治したら元に戻りました。
昨日（2025/07/19）ですが、進捗を書くのをサボりました。
すいませんね。
睡魔だけに。
昨日は本来なら50分0ビルド縛りをするつもりだったのですが、気づいたら2時間でした。
いや、ビルドをなくすだけでコーディングの効率が八倍くらいに跳ね上がりましたね。
多分ビルドしながらやってたら2時間はかかってたであろうところを1時間くらいでコードはできましたし。
まず初めの1時間で作ったのはPlayer_Magic側のコーディングです。
インスタンス化やそれのための流れはLight_Ballの時に学んだので、意外とサクッといけました。
その後が問題です。
今回作ったMagicStar（今考えた。明日名前変える）なのですが、通常攻撃キーを長押ししてパワーを貯めて話たら一斉発射というものですね。
最大10秒間星を生成し続けることができ、星の数は最大10個です。
つまり1秒溜めれば1個という感じですね。
そこはパラメーター化してあるのでゲームのステージができたり、敵ができた時に反撃までに時間がかかるとか感じたら調整する所存です。
まず初めの1時間でspawnStarというメソッドを作りました。
その時の話が↑です。
そのあと、書いたコードがインスペクターに反映されるのを待つ間にPowarStarの方のコーディングをしました。
その時は溜めつつも若干動くことはできるというふうにするつもりだったのでプレイヤーの後ろを追尾するように作りました。
そしてPlayer_Magicの方にもスピードが遅くなるようにコーディングしました。
で2時間。
そしてようやくビルドしてみると、星が出てきません。ここで昨日はタイムアップでした。
そしてやってくる次の日の朝日と雀が私を起こしてくれました。
そんな話は置いておいて、今日は（2025/07/20）昨日表示されなかった理由を探りました。
まずはいつものエラーが出ていたので（パスのやつ）サクッと10分くらいで解決して、そのあと30分くらい探し続けた結果、ビルドしてちょっといじってる時に偶然空高くに打ち上げられたらはるか上空に星があったので数値を調整し下に来るようにしました。
あとはちょっとチューニングして完成という感じです。
初期状態が。
その後乱数で場所が若干ずれてたくさんある感を増させました。
あと、プレイヤーに追尾してくれないので一旦追尾させるということをやめて、プレイヤーは貯めている間動けないというふうにして保留という感じにしてあります。
その後、気分転換にファイルシステムの方を整理しました。
GameObject、Shared、Audioの3つに分類し、そこからさらにGameObjectはPlayer(Player_Magic（Projectile(LightBall(cs/tscn))(PowarStar(tscn/cs/(model(star.glb))))))という感じでまとめました。まとめた後の清々しさいいですね。
フォルダも着色して一目でわかるようにしました。
いや、整理する前のシーンとCSファイルとglbが並列に並んでいるあのぐちゃぐちゃかん本当にやばかったのでスッキリして嬉しいです。
明日はボタン長押しをやめたらStarが前方に飛んで行くようにします。
でそのためにまずは番号を振る必要があるんですよ。
順番に飛ばしたいので。
かなり苦戦しそうですが、また2時間0ビルドチャレンジでやろうと思うので頑張ります。
実際のコードは書かないでね。
試行錯誤が楽しいからさ。

今日はLightBallが出なくなっていた問題があったのでそちらの方を解決しました。
私は初め、JustPressedとPressedがバッティングを起こしていて発射されないと予測していてその方向で修正していたのですが、出ませんでした。
でそのあとデバッガーに出てきているエラーを見たら、パスが間違っているとのことでした。
どのパスを間違えているか色々見ていたら、最終的にインスタンス化する時のファイルのパス（ノードツリーの方ではない）が間違っていました。
今回やったのはそれだけです

Day29は何やかんやありまして、駆り出されていました。
仕方ないですね。

Day30は今日までずっと戦ってきた不具合、PowerStarがプレイヤーを追尾してくれない問題の方をやりました。
費やした時間は2時間。
原因は根本的な仕組みの方にありました。
最初はプレイヤーの位置にtargetPositionというインスタンス化された時の位置を保存する役割のあるVector3型の変数があるのですが、それが原因だったので、offsetという変数を作り、プレイヤーとの距離を計算してそこからプレイヤーのGlobalPositionを足して位置関係を保つという仕組みに変えました。
仕組み自体は限りなく正解に近いのですが、欠点があります。
そう、プレイヤーが中心とすると0,0,0にインスタンス化された後すぐに行ってしまうのです。
理由は簡単です。
PowerStarがインスタンス化された後、プレイヤーの方で1フレーム後に場所を移動させるのですが、その移動させる前のフレームで場所とプレイヤーの関係を記録していたのがネックでした。
なのでプレイヤーが持っているtargetPositionというスターをどこに配置させるかを司る変数、人でいう脳ミソまたは心臓的な役割の変数ですね。
それをstar.csで参照させてその変数とプレイヤーの位置で関係を維持するようにしたら安定するようになりました。
それで終わりではないです、試しにビルドしてやっていたら遠くなるほどスターが画面から消えていくと言う現象が起こりました。
それの原因を究明すべく、私お手製のパラメーターを変えるだけで位置を変えられる、しかもビルド中も可能なカメラの方を使い原因を究明しました。
まず起こっていた現象はプレイヤーとリス地（0,0,0）との距離だけプレイヤーから離れたところにStarが生成されていました。
で、そのようになっている原因はプレイヤーがわのtargetPositionには最終的にplayerPositionというプレイヤーの位置を足していたため遠くなったというのが原因でした。
そのコードを消したら直りました。
でその後、プレイヤーの向いている方向に飛ぶようにしたり、待機中は回転するようにしたり、生成される場所の微調整をしたり、飛んでいる時はチャージしている状態を検知して発車後に止まらないようにしたりと微調整をし、チャージ攻撃は90％くらい完成しました。
あとは細かい調整で仕上げるだけです。
明日にはチャージ攻撃が完成します。
いやぁ。
なんやかんやプレイヤーに追従しない問題とかインスタンス化された時に生成される場所がおかしいっていう問題、一週間くらいずっとやってた気がするからめっちゃ嬉しかった。
久々にプログラミングの醍醐味を感じたよ。
私の名前はナナシです。
私はパソコンが好きです。
私はスーパーコンピューターが必要です。

Day29は何やかんやありまして、駆り出されていました。
仕方ないですね。

Day30は今日までずっと戦ってきた不具合、PowerStarがプレイヤーを追尾してくれない問題の方をやりました。
費やした時間は2時間。
原因は根本的な仕組みの方にありました。
最初はプレイヤーの位置にtargetPositionというインスタンス化された時の位置を保存する役割のあるVector3型の変数があるのですが、それが原因だったので、offsetという変数を作り、プレイヤーとの距離を計算してそこからプレイヤーのGlobalPositionを足して位置関係を保つという仕組みに変えました。
仕組み自体は限りなく正解に近いのですが、欠点があります。
そう、プレイヤーが中心とすると0,0,0にインスタンス化された後すぐに行ってしまうのです。
理由は簡単です。
PowerStarがインスタンス化された後、プレイヤーの方で1フレーム後に場所を移動させるのですが、その移動させる前のフレームで場所とプレイヤーの関係を記録していたのがネックでした。
なのでプレイヤーが持っているtargetPositionというスターをどこに配置させるかを司る変数、人でいう脳ミソまたは心臓的な役割の変数ですね。
それをstar.csで参照させてその変数とプレイヤーの位置で関係を維持するようにしたら安定するようになりました。
それで終わりではないです、試しにビルドしてやっていたら遠くなるほどスターが画面から消えていくと言う現象が起こりました。
それの原因を究明すべく、私お手製のパラメーターを変えるだけで位置を変えられる、しかもビルド中も可能なカメラの方を使い原因を究明しました。
まず起こっていた現象はプレイヤーとリス地（0,0,0）との距離だけプレイヤーから離れたところにStarが生成されていました。
で、そのようになっている原因はプレイヤーがわのtargetPositionには最終的にplayerPositionというプレイヤーの位置を足していたため遠くなったというのが原因でした。
そのコードを消したら直りました。
でその後、プレイヤーの向いている方向に飛ぶようにしたり、待機中は回転するようにしたり、生成される場所の微調整をしたり、飛んでいる時はチャージしている状態を検知して発車後に止まらないようにしたりと微調整をし、チャージ攻撃は90％くらい完成しました。
あとは細かい調整で仕上げるだけです。
明日にはチャージ攻撃が完成します。
いやぁ。
なんやかんやプレイヤーに追従しない問題とかインスタンス化された時に生成される場所がおかしいっていう問題、一週間くらいずっとやってた気がするからめっちゃ嬉しかった。
久々にプログラミングの醍醐味を感じたよ。

ナレーション：元亀三年（1573年）、武田信玄は徳川家康の支配する三河への進出を目指し、織田・徳川連合軍と対峙することとなる。
味方ヶ原の戦場は、名だたる武将たちの知略と覚悟が交差する運命の地となった。
 このナレーション時は舞台にあるカーテン？をスクリーンがわりに使い、影だけの映像を流す。
武田信玄（以後、T）：侵略は火の如く。
（武田信玄役の人が観客の方を向く）相手がどれほど弱 かろうと、我は油断はしない。）
( 再び観客に背を向け、ステージの右端へ＆徳川家康役がステージ外の左端へ移動。）
（観客に背を向ける。)
ナレーション：徳川家康役、〇〇さん。
 
徳川家康（以後、徳川）：我が国の興廃はこの1戦にあり。
（観客を向く）
みな、いつも以上に努力せよ！えいえい。
T：知り難きこと陰のごとく。
（観客を見る）我が軍には陰の如く奴等の情報を抜き取る影衆がいる。
この戦い。
わたしがもらった。
影衆：この戦い、わたしの力で勝利へ導いて見せましょう。
徳川：いいや。
そうはさせないぞ！我が軍には雷鳴の如く敵を蹴散らす雷鳴剣の使い手、風雷がいる。
風雷：吾輩の剣の腕を舐めてもらっちゃぁ困るな。
陰衆だかなんだか知らないが、吾輩の剣で切り刻んでやるわ。
織田：おっとおっと。
わたしのことを忘れてもらっては困るな。
え、違うの？あぁ、それは長篠の戦いか。
すまない。
間違えた。
（頭を撫でながら裏へ歩く。)
（その時、スポットライトを片方ずつ消していく。)
（カーテンが閉まり、徳川と風雷が裏方へ戻っていく。)
（スポットライトなし））
（カーテンをスクリーンのようにして、映像を流す。)
ナレーション：この時、戦国の世は乱れに乱れていた。
京の将軍・足利義昭は武田信玄に救いを求める。
織田信長が力を伸ばし...。
（ナレーションは切れてカーテンの間から織田信長が出てくる） 
織田：やっぱりわたしの言ったことは正しかったじゃないか！ 
ナレーション：はいはい、わかりました。
わかりましたから！ 
織田：本当に？ 
ナレーション：はい。
物語が進まないから、早く戻って！ 
織田：なんか.........すいません。
（スポットライトが消えて織田がカーテンの中へ戻っていく） 
ナレーション：続けます。
織田信長が徳川家康と共に力をつけ、勢力を広げる中、信玄は決断する。
（Tが徳川家康のいた場所にやってくる。）
武田：（スポットライト（赤としろ））今こそ、天下へ進むときだ。
我々で天下を取るぞ！（スポットライトが消え、武田は裏方へ戻っていく） 
ナレーション：名だたる騎馬軍団が甲斐を出発し、東海道へと進軍を始めた。
次の標的は三河。
そして最終的には京。
戦いの火蓋は斬られ、運命の歯車が大きく回り始めた。
武田：たった3日で落とした三俣城。
ここから西上作戦を続けたいのだが、向かいにある浜松城に いる徳川が邪魔だな。
あっちもどうにかして攻め落としたいな。
どうするべきか。
（しばらく一人で考え込む。）
（その後スポットライトとステージ照明が消える。）
（徳川家康にスポットライトが向く、ステージ外照明がつく） 
徳川：掛川城包囲中に武田の秋山虎繁に攻撃されたからな。
もしかしたらせめてくるかもしれないな。
しばらく様子見だな。
（ステージの上から徳川を見ている陰衆にスポットライトを当てると同 時に裏方へ。）
（スクリーンの裏を回って反対側へ）
（ステージ照明がつく）
（陰衆が武田へ走っていく。）
 陰衆：徳川は我々の動きを見てから動くとのことです。
武田：調査ご苦労であった。
しばらく休んで良いぞ。
陰衆：はい→！（ヤスコみたいに（冗談）（笑））（退場） 
武田：（しばらく考え込む）
（考え込んだ後にステージ照明が消え、スポットライトのみになる。）
相手が我々の様子を見て動かないのなら、我々が無理やり動かさせるしかないな。
 （スポットライトもきえる）
（ステージ外照明がつき徳川にスポットライトが向く） 
徳川：奴らが来たらすぐに出陣できるように、門の近くに兵を集めろ。
 
風雷：は！ 
（ステージ外照明が消え、風雷は階段からステージに上がり、武田の横の裏方へ走る）
（この間に裏方は武田信玄に地図を渡す。）
（スポットのみで武田を映す） 
武田：軍をこのように動かして相手を誘き寄せてみたらどうだ？ 
陰衆：いいですね！ 
武田：じゃあ、この作戦で行くか。
 （スポットライトの片方が徳川を写す） 
徳川：やつが正面からきたら、群を3つに分裂させ、2つは城の後ろから出て左右に分かれて武田軍を左右から攻撃、正面にいる1つの軍は囮にする。
風雷：これで決まりですね
徳川：ああ。
そうだな。
 （スポットライトが消え、幕が閉じる。)
（カーテン？をスクリーンとして使い、夜の城の中を再現した映像を流す。） 
ナレーション：あれからしばらくたって夜10時ごろ。
あたり一面は暗闇に包まれていた。
今日の月は満月。
風も雲も一切なく、静寂が貫き通っていた。
 （カーテンがあき、ステージない照明（オレンジ）がつくスポットライトは片方のみ） 
徳川：夜に武田が襲撃してくるかもしれない。
皆、警戒を怠るな。
（音響：たくさんの馬の足音が聞こえてくる。） 
徳川：武田がきたぞ！全員構えろ！門の前に集まれ！ 
武田：（ステージ外を使い、馬の模型を持った武田が徳川の周りを大きくぐるぐる回る。） 
徳川の部下1：囲まれたかもしれない！逃げろー！ 
徳川の部下1＆2：（徳川の近くを走ってうろちょろして裏方へ行く） 
徳川：おいコラ、なんで逃げるのだ！（武田のいけーという声が聞こえる）ああー逃げろー！みんなにげろー。
（武田は動かないで待機）（徳川は裏方へ） 
武田：（スポットライトが武田を向く）よし、徳川のやつ城の中に逃げていったぞ！作戦成功だ。
帰るぞ！ （スポットライト、ステージ内照明がきえる） （カーテンが閉まる。）
（カーテンに太陽が登る様子を映す） ステージ内照明がつく 
徳川：驚かせやがって、せめてないじゃないか！あいつは許さんぞ！ 次きたら問答無用でぶちのめしてくれるは！ 風雷、昨日みたいに、軍を門の前に集めろ！ 
風雷：は！

どうもこんにちは、ロクペンです。

このブログではweb制作の技術やゲーム開発の過程などを記録していくために使っていこうと思います。
読者の皆さんの参考になったら嬉しいです。
では早速行ってみましょう。


自己紹介

まずは私の方から自己紹介させていただきます。


音楽
私はクラシック音楽とカービィのBGMが大好きです。

クラシック音楽は曲によって色々な個性があって、本当に興味深く、大好きです。

カービィの音楽の中でも「狂花水月」が大好きです。
優雅さ、悲壮さ、爽快さの3つが合わさっている素晴らしい曲であり、とても好きです。


プログラミング
プログラミングについては、言わずもがな、これまで取り組んできた分野の一つです。
今までWeb制作にも力を入れてきましたが、最近ではゲーム制作にも興味を持ち始めました。
ゲーム制作の過程についても、今後ブログで投稿していこうと考えていますので、ぜひ楽しみにしていてください。


鳥が好き
私は幼少期から鳥が大好きで、よくバードウォッチングに出かけています。
鳥はその小さな体、丸いフォルム、そしてつぶらな瞳がとても愛らしく、見ているだけで癒されます。
中でも、特にペンギンが大好きで、実は私のアイコンにもペンギンを使っています。


このブログを始めたきっかけ

私はこのブログを、自分の技術を共有したり、読者からの意見を受けてさらに技術力を高めていくために始めました。
また、私のように初心者で「具体的に何をすれば良いのか分からない」と感じている人が少なからずいると思います。
そんな人たちには、私のような経験をしてほしくないと思っています。
少しでもそのような人が減るように、このブログを書いています。


まとめ

ここまで読んでくれてありがとうございます。
私はこのブログを通じて、自分が学んだことや経験を少しでも多くの人にシェアできたら嬉しいです。
Web制作やゲーム開発の過程で得た知識を、初心者の方でもわかりやすく、時にはちょっと楽しく伝えていけたらと思っています。
コメントや質問もどんどん受け付けていくつもりので、気軽に声をかけてくださいね！ これからも色んな情報をお届けしていきますので、楽しみにしていてください。
それでは、次の記事でお会いしましょう！

みなさんはBlenderを使っていますか？現在（2025/07/03）私は永遠とキャラクターのモデルを作り続けています。
進んでないわけではないのですが、ずっと同じことをやっている気がします。
ゲーム制作を行なってるみなさんも気をつけるべきだと思います。


〜注意事項〜

この記事は、「条件分岐」や「関数」など、プログラミングの基本的な概念を知っていることを前提に書かれています。

基礎的な内容にはあまり触れていないため、もしそういった知識がまだない場合は、入門向けの記事を先に読むことをおすすめします。
（今はちょっと余裕がなくて書けていませんが、今後は初心者向けの記事も投稿する予定です。
お楽しみに！）
また、すでにC#をしっかり理解している方にとっては、退屈な内容に感じられるかもしれません。

ですが、初心に戻って基本の意味を改めて確認してみるのも、新しい発見につながるかもしれません。


~Day1 2025/6/23~

環境構築も終わりましたし、ゲーム制作の方に入っていこう！
…と言いたいところですが、何を作るか決まってすらいないのに、いきなり制作を始めるなんてできません。
ということで、まずは 「どんなゲームを作るか」 を決めていきましょう。


アイデアづくり① ー ジャンルを考える
何がいいでしょうか？
やっぱり、マリオとかカービィみたいな2D横スクロールアクションが作りやすそうだし王道っぽい。

 でもちょっと憧れちゃうのは3Dアクション。
立体的な空間で、自由に動き回れるゲームとかいいなぁ。

じゃあ一回、候補をざっと書き出してみます：

2D横スクロール
3Dアクション
シミュレーション
3Dアクションと2D横スクロールで正直めっちゃ迷ってる。

 3Dの世界で縦横無尽に動き回って、ボスとバトルとか…想像しただけでめっちゃ楽しそう。
でも初心者が作るって言ったら、やっぱり2Dアクションゲームが現実的だしなあ……。


いっそのこと、混ぜてしまえば？
そうだ、もう混ぜちゃおう。
2Dベースで操作はシンプルに。

でも、背景や演出はちょっと3Dっぽくして、ボス戦だけ急に立体感が出てくるとか――「見た目はシンプル、でも奥行きのあるゲーム」って、作れたらめっちゃ面白そうじゃない？
じゃあ、2.5Dアクション横スクロールゲームにするっていう方向でやってこう！

アイデアづくり② -ゲームの要素-
ゲームにするからどういう要素があるかとか決めていこう。

まず、横スクロールゲームだから、左右移動、ジャンプは必須だよね。
二段ジャンプとかもできたら面白そうだな。
攻撃だけど1種類とか2種類だと物足りなさそうだから10種類くらい作っちゃう。
通常攻撃、通常弱攻撃、通常上攻撃、ため攻撃、強攻撃、上強攻撃、強ため攻撃、あとは必殺技とかかな。
まあプレイヤーはこのぐらいにしておこう。

横スクロールゲームの敵って1種類か2種類の攻撃しかしてこないよね。
でもその方がギミックとして使いやすいけど、5種類くらい攻撃できるやつがいても面白そう。

ステージの絵ステージとかどういう感じにしようかな。
カービィとかマリオみたいに区切りをつけてステージを移動するか。
それか1つのでっかいマップにしてその中を探索するとか。
広いマップで探索できるようにしたら面白いね。

コインとそれを消費すると貰えるものやっぱり王道のコインは必要だよね。
でもコインがあるってことはそれを消費しなければならないわけだ。
何で消費させるか......スキルとか？それか服を買えるようにしてコスチュームを変えられるようにしたらどうかな。
面白そうだけど、技術的に難しそうだな。
じゃあ、武器を買って自分をアップグレードできるようにしたらどうだろう。
例えば、今まで持ってた竹刀で攻撃すると攻撃力は+10しか足されないけど、鉄の剣にしたら攻撃力が+100されるみたいなふうにしたらいいんじゃね？武器のアップグレードはモデリングが服よりは簡単にはなるが、技術的難易度は変わらないかな。

ストーリーとかどうしようか。
やっぱりつけた方がいいかな。
でも今作は作る方に集中したいからなくていいか。
でもつけたいなぁ......じゃあ、モードとかを2つにしてストーリーありとなしを分けたらいいんじゃない。
片方のモードはストーリーがなくて純粋にアクションを楽しむ。
もう片方はストーリーがあってそれを楽しみつつもアクションを楽しむっていうふうにしたらいいんじゃない？いいね。
そうしよう。
ストーリーは後で考えよう。

じゃあ、今考えた要素をまとめよう。

左右移動 / ジャンプと二段ジャンプ / 攻撃は10種類 / 広大なマップを探索する / コイン→武器を買って自分の攻撃力とかをグレードアップ / ストーリーなしのアクションを楽しむモード・ストーリーを楽しむモード

じゃあ、これを軸に明日からゲームを作っていこう！

~Day2 2025/6/24 -初めての自力コーディング- ~

よし！じゃあ、早速作っていこう。
まずはどういう順番で何を作っていくかを決めよう。
今最低限プレイヤーに必要なのは、

左右移動
ジャンプ
二段ジャンプ
攻撃
優先順位をつけて整理してみよう！でも、この順番でいいや。
まずは左右移動から作っていこう。
とその前に、PlayerのSceneの方を作っていこう！

まずはCharacterBody3Dを追加していこう！

CharacterBody3Dを追加している様子 Godot使うなら絶対に知っておけ！ - CharacterBody3Dってなんだ！
CharacterBody3Dはプレイヤーキャラクターや敵キャラクターのような能動的に動く存在を制御するために設計されたNodeです。
特に「重力やジャンプ、移動」といったゲームでよくキャラクターが使う動きを簡潔に記述できるように作られているのが特徴です。

CharacterBody3Dは、物理ベースの移動を行うための"Velocity"プロパティと、衝突を考慮しながら移動を処理する"MoveAndSlide()"メソッドを標準で備えています。
これらをうまく活かすことで、重力や床との滑りなどの基本的なキャラクターの挙動が自然に再現できます。


つまり、CharacterBody3DやRegidBody3D以外のテキトーなNodeを使って動きをプログラミングするよりもCharacterBody3Dを使う方が楽に移動、ジャンプを作ることができる且挙動が自然になるのです。
まあ、最初はプレイヤー、敵を作る時に使うのはCharacterBody3Dくらいのノリで覚えておいてください。


collisionShape3Dを追加している様子
次にCollisionShape3Dを追加します。


これを知らなきゃ話にならない。
CollisionShape3Dって何？
CollisionShape3Dは、物理演算を行うための形状情報を与えるためのNodeです。
つまり、Godotにおける「当たり判定の形＝Shape」を定義するNodeです。
単体では機能せず、CharacterBody3DやRigidBody3D、Area3Dなどの物理Nodeの子として使われます。
親Nodeに"どの範囲に当たり判定を持たせるかを教える"役目を果たしています。


これがないと例えば重力を作ったとしても床をすり抜けて落ちていっちゃうとかそういうふうになります。
CharacterBody3DやRigidBody3D、Area3Dとセットで追加するというふうに思っていればOKです。


meshInstance3Dを追加している様子
最後にMeshInstance3Dを追加していきます。


これをなくしてゲームは成り立たない。
MeshInstance3Dとは何者？
MeshInstance3Dは、Godotで3Dモデルをシーン上に表示するために使うNodeです。


わかりやすくいうと、親Nodeに「視覚的な形状＝メッシュ＝"見た目"」を表示させるNodeです。


たったこれだけです。
ただ単に見た目を作るだけ、ただそれだけです。
CharacterBody3DまたはArea3DなどとCollisionShape3DとMeshInstance3Dのこの3セットを追加すると思っておけばいいと思います。
これなら最低限の動きは作れるでしょう。


さあ、長ったらしい解説はここまでにして、早速スクリプトをアタッチしていきましょう！

プレイヤーをコーディングだ！

using Godot;
using System;

public partial class player_magic : CharacterBody3D
{
    [Export]
    public float Speed = 5.0f;

    private Vector3 direction = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        if (Input.IsActionPressed("moveRight"))
        {
            direction.X += 1;
        }
        if (Input.IsActionPressed("moveLeft"))
        {
            direction.X -= 1;
        }

        Velocity.X = direction.X * Speed;

        MoveAndSlide();
        direction = Vector3.Zero;
    }
}
このコードはチュートリアルを参考にしながら作りました。
序盤の基本的な動作とかの導入は結構チュートリアルが役立つと思うので、覚えておくといいでしょう。
ではコードの解説に写っていきます。


using

using Godot;
using System;
GodotでC#を使うとき、using Systemとusing Godotを最初に書くことで、C#の標準機能やGodotのゲーム開発に必要なクラスを簡単に使えるようになります。
Systemは基本的な操作（リストやファイル操作など）を提供し、Godotはゲームに必要なクラス（NodeやVector2など）を提供します。
他にも、特定の機能を使いたいときにusingで追加することができます。


めちゃくちゃわかりやすくいうと、Systemっていう名前のおもちゃの箱とGodotっていう名前のおもちゃの箱があるとします。
using Systemと書くとSystemの箱の中の"おもちゃ＝コード"を"using=使える"ようになります。
using Godotと書くと、"Godotの箱の中の"おもちゃ＝コード"が"using=使える"ようになるという感じです。


-変数について-

[Export]
    public float Speed = 5.0f;

    private Vector3 direction = Vector3.Zero;
[Export]っていうのはその下にある変数をパラメーターにする時に使う、いわゆる呪文とかおまじないってやつです。
この[Export]と入れることで一回一回コードを書いてエディター上で数字を変えるという作業をしなくても、開発エンジンのインスペクタ上から自由に数値を変えることができるようになります。
SpeedやGravity（重力）など、頻繁に調整することのある変数をパラメーター化しておくと便利です。


次に、publicとprivateについて説明します。
先に言っておきますが、Godotでゲーム開発をする場合、どちらを使うかを気にする必要はあまりありません。
私はアプリ開発もしているため、感覚を忘れないように意識的に使い分けていますが、Godot内での挙動には特に違いはありません。
実際、C#ではprivateにした変数は他のスクリプトがアクセスできなくなり、publicにした変数は外部からもアクセスできるという意味があります。
しかし、GodotのC#スクリプトでは、publicでもprivateでも、インスペクタからのアクセスに違いはありません。
そのため、Godotで開発する場合、publicやprivateは、コードの外部アクセスを意識する場合にだけ使うくらいで大丈夫です。
変数を作ったり、関数使ったりするときにとりあえずつけておくものと思っていてください。


変数を作る時には次のようにコードを打ちます。



public [型名] [変数名] = [数値];
このpublicやprivateの後に来ているのが型名です。
型名はたくさんありますが、ゲーム開発やアプリ開発でよく使うものをいくつか紹介しましょう。


int：ただの整数。
（1,2,3,4,5...）
float：小数点付きの数字。
（1.2f,4.1f,99.99f....）
string：文字列（こんにちは、HelloWorld...）
character：1文字（A,B,C,あ,い,う...）
bool：trueかfalseのどちらか
Vector2：2次元の座標（x,y)
Vector3：3次元の座標(x,y,z)
これらは頭に絶対に入れておいてください。
C#でやる場合は特に。
C#はオブジェクト指向型のプログラミング言語なので、変数の作成や変数への代入時にはどの型か指定する必要があります。
例えば、numberという変数に8.2を代入する場合、public float number = 8.2f;というふうに描きます。
ここで重要なのは、数値や変数に型を指定しないとエラーが起きるという点です。
例えば、float型に整数を代入したり、int型に小数点を代入しようとすると、コンパイラが「型が一致しません」とエラーを出して、コードが正常に動作しません。
これを回避するために、適切な型を使うことが大切です。


public float Speed = 8.0f;


public float Speed = 8.0f;
_PhysicsProcess

public override void _PhysicsProcess(double delta)
{
   //ここに処理を書く
}
public override void _PhysicsProcess(double delta)は、物理演算用の処理を実行するための関数です。
固定フレーム間隔で処理が実行します。


ゲームの実行環境が変わっても一定のフレームレートで動作してくれるので、物理演算に向いています。


MoveAndSlide()

MoveAndSlide();
MoveAndSlide()はゲームエンジンでよく使われる移動メソッドです。
主にキャラクターの移動やオブジェクトの移動処理に使われます。
普通に位置を変えるだけでなく、「滑るような動き」や「壁や床との衝突判定」を自動的に処理してくれるのが特徴です。


この関数はCharacterBody3DとRigidBody3Dだけでのみ使える関数です。
CharacterBody3DやRigidBody3Dでもキャラクターやオブジェクトの移動の処理をさせるときに移動処理の後に書くものと思っておいてください。


このコードを実行すると...

public override void _PhysicsProcess(double delta)
    {
        if (Input.IsActionPressed("moveRight"))
        {
            direction.X += 1;
        }
        if (Input.IsActionPressed("moveLeft"))
        {
            direction.X -= 1;
        }

        Velocity.X = direction.X * Speed;

        MoveAndSlide();
        direction = Vector3.Zero;
    }
実はこのコードをビルドすると実は以下のようにエラーが出ます。


CS1612: 変数ではないため、'CharacterBody3D.Velocity' の戻り値を変更できません /Users/******/GodotProject/BaRont/player_magic.cs(22,3)===>Velocity.X = direction.X * Speed;

これは構文が間違っているため出たものです。
CharacterBody3Dが元々持っているメソッドVelocityに.Xや.Yなどのプロパティをつけることはできないのでエラーが出ました。
これはVelocity.X = direction.Xとするのではなく、Velocity = directionとする必要があります。

Day2終了時点でこのことには気づいてなかったのでDay3で直しました。


~Day3 2025/6/25 -ゲーム開発は甘くない-~

では、早速昨日言ったところを修正していきましょう！


public override void _PhysicsProcess(double delta)
    {
        if (Input.IsActionPressed("moveRight"))
        {
            direction.X += 1;
        }
        if (Input.IsActionPressed("moveLeft"))
        {
            direction.X -= 1;
        }

        Velocity = direction * Speed;

        MoveAndSlide();
        direction = Vector3.Zero;
    }
こうすることで正しく左右に移動します！ってことで前回（Day2）解説していなかったところを解説していきます！

Input

Input.IsActionPressed("moveUp")
Input.IsActionPressed("moveUp") は、プレイヤーが「moveUp」という名前の入力アクションを押している間、true を返し、押していないときにfalseを返す関数です。

moveUpはインプットマップと呼ばれる操作方法の設定の画面で決めることができます。
後ほど説明します。


正しいコードの仕組み
このコードではどのようにしてキャラクターを動かしているかを解説します。


1. public override void _PhysicsProcess(double delta)でマイフレーム描画するように指定します。

2. if(Input.IsAvtionPressed("move ****")でmove****を検知します。

3. 検知したらdirection（=方向）に1を増やしてdirection=(1,0,0)にします。

4. VelocityにdirectionにSpeedをかけた数字を代入します。

5. MoveAndSlide()でオブジェクトを動かすということです。


ここまでだけで動きそうですが、このあとが重要です。

6. 最後にdirectionをリセットすることでボタンを押したら永久に動き続けることを防止します。


この6.がないと、directionは1となり、リセットされないため、永遠と動き続けることになります。
まあ、ここでこのあと始まるジャンプの実装時に起こる問題の原因となるのですがね。
この時は知らないので。


全ての始まり、重力
じゃあ、左右移動の次はジャンプの仕様を作っていきます。
ジャンプは重力という要素が必須なので、まずば重力から作っていきましょう。



using Godot;
using System;
using System.Globalization;

public partial class player_magic : CharacterBody3D
{
    [Export]
    public float Speed = 1.0f;
    [Export]
    public float Grabity = 1.0f;

    private Vector3 direction = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {

       //省略

        if (IsOnFloor() == false)
        {
            direction.Y -= Grabity;
        }
        else if (IsOnFloor() == true)
        {
            direction.Y = 0;
        }

        Velocity = direction * Speed;
        GD.Print(Velocity);
        MoveAndSlide();
        direction = Vector3.Zero;
    }
}
1発でエラーとかバグが起こらずに完成できました。
ではコードの解説の方に移ります。



 [Export]
    public float Grabity = 1.0f;
ここでGrabityを宣言しつつ、パラメーター化しています。
結構作っている途中で変えたくなるのでね。




        if (IsOnFloor() == false)
        {
            direction.Y -= Grabity;
        }
        else if (IsOnFloor() == true)
        {
            direction.Y = 0;
        }
ここで重力の処理を行っています。
IsOnFloor()という関数を使って床に触れているかを検知し、触れていなかったら、directionのYをGrabityずつ減らしていき、落下。
触れている時はdirectionを0にして落下しないようにするという感じです。



        MoveAndSlide();
最後にMoveAndSlide()でdirectionを動きに反映して重力の処理をするという感じです。


地獄のジャンプ実装
重力もできたので、早速ジャンプの方作っていきましょう！


まずはジャンプ力っていうかジャンプ時の上昇量を決めましょう。
おそらくこの変数は頻繁に変えることになるので、[Export]でパラメーター化しちゃいましょう！


[Export]
public float JumpPower = 1.0f;
パラメーターにする数字は初期値を入れるかテキトーな数字を入れるとかしておいてください。
私は初期値を入れました。


では次に、ジャンプをする仕組みを作っていきましょう。


一回ジャンプがどのようにされているか整理してみましょう。



1. ジャンプするボタンを押した時に上方向への力を加える
2. 下方向への力は加え続ける

基本的にこれだけで自なジャンプはできます。


ジャンプの軌道の様子
では早速これをコードにしていきましょう。



if (IsOnFloor() && Input.IsActionJustPressed("Jump"))
{
    direction.Y = JumpPower;
}
このコードを説明すると、地面に触れている且つジャンプボタンが押されたら、direction.YをJumpPowerにするというものです。
&&が且つという意味で、左右にある関数がどちらもtrueを返したら、trueを返します。
（なんか小泉構文みたいですね。
）また、少なくとも一方がfalseだったら、falseになります。
これらを論理演算子と言うのですが別の記事でじっくりと説明しようと思いますので出てきたら簡単な説明をすると言うふうにしようと思います。



ではこれで動かしてみましょう。

あれ？おかしいですね。
ジャンプしてくれません。
 では、原因究明のためにdirectionがどうなっているかみてみましょう。
コードの一番最後で


GD.Print(direction.Y);
これを入れることでコンソールにdirectionのYの数字を見ることができます。
この状態でビルドするどうなるでしょう。


全ての数字が0の様子
全部0ですね。
ここから推測するに、おそらく、コードの1番最後のこのコードが邪魔をしているのではないでしょうか。



direction=Vector3.Zero;
このコードはマイフレーム、directionを0にしています。
つまり、自分の想定では上方向への力JumpPower分の力が入り上へ飛んでいくのですが、directionがすぐに0になるため、上へ押す力がリセットされてしまうと推測されます。
では次回、最後のコードを消してみようと思います。


~ 締め~

今回はゲームの方向性を決めた後、左右移動の仕組みを作りました。
 ただ、このコードには誤りがあったため、明日（Day3）で修正します。
 本当はDay2〜Day7までをまとめて1記事にする予定でしたが、想定以上に解説が長くなってしまったので、今回はDay2とDay3 だけの記事としてお届けします。

次回はジャンプや二段ジャンプの実装にチャレンジするので、どうぞお楽しみに！
それでは、バイバイ！

みなさん！こんにちは！最近はブログのサムネや記事の途中で出てくる説明のための画像に、自分で描いたイラストを使っています。
ゲーム制作を始めてから絵が上手くなった気がします。
ブログの方ですが、SEO対策を強化しました。
これでより検索上位に出やすくなったのではないでしょうか。
2025/07/09の段階では「Godotのチュートリアル」と検索すると6ページ目の上から3番目に出るようになりました。
今後もSEOとかOGPとか頑張っていきますので、よろしくお願いします。


~注意事項~

この記事は、「条件分岐」や「関数」など、プログラミングの基本的な概念を知っていることを前提に書かれています。

基礎的な内容にはあまり触れていないため、もしそういった知識がまだない場合は、入門向けの記事を先に読むことをおすすめします。
 （今はちょっと余裕がなくて書けていませんが、今後は初心者向けの記事も投稿する予定です。
お楽しみに！）
また、すでにC#をしっかり理解している方にとっては、退屈な内容に感じられるかもしれません。

ですが、初心に戻って基本の意味を改めて確認してみるのも、新しい発見につながるかもしれません。


~Day4 2025/6/26 -Jump Up GameCreator-~

はい、じゃあ今日もやっていきましょう。
まずは昨日何をやったかを思い出すところから。



using Godot;
using System;
using System.Globalization;

public partial class player_magic : CharacterBody3D
{
    [Export]
    public float Speed = 1.0f;
    [Export]
    public float Grabity = 1.0f;
    [Export]
    public float JumpPower = 1.0f;

    private Vector3 direction = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        if (Input.IsActionPressed("moveRight"))
        {
            direction.X += 1;
        }
        else
        {
            direction.X = 
        }
        if (Input.IsActionPressed("moveLeft"))
        {
            direction.X -= 1;
        }
        else
        {
            direction.X = 0;
        }
        if (IsOnFloor() == true && Input.IsActionJustPressed("Jump"))
        {
            direction.Y = JumpPower;
        }

        if (IsOnFloor() == false)
        {
            direction.Y -= Grabity;
        }
        else if (IsOnFloor() == true)
        {
            direction.Y = 0;
        }

        Velocity = direction * Speed;
        GD.Print(Velocity);
        MoveAndSlide();
        direction = Vector3.Zero;
    }
}
前回の切り抜き
このコードはマイフレーム、directionを0にしています。
つまり、自分の想定では上方向への力JumpPower分の力が入る、すぐに0になるというふうだと思われます。
では一回、最後のコードを消してみようと思いま...
では、一番下の


direction = Vector3.Zero;
    
を消します。
どうやって動くでしょうかね。

はい、今までみたいにジャンプしないという状況にはなりませんでした。
ただ挙動がちょっとおかしくて、上に一気に上がって少しずつ落ちていくというふうになっていますが。
そして左右移動をすると永遠と進み続けるやばい挙動ですね。
じゃあ、修復していきましょう！

アイデア① -Xだけをリセット-
じゃあ、Xだけをリセットしましょう。



Velocity.X = 0;
    
エラーが出ている

構文エラー

ダメみたいですね。


アイデア② -directionをリセット-
これならどうだ！


direction = Vector3.Zero;
    

Godotのロゴ
無駄だぜ！

ダメですね。
ジャンプしてくれません。


アイデア③ -direction.Xだけリセット-
最終手段だ。
これならどうだ！


direction.X = 0;
    

OK！無事ジャンプしてくれました。

じゃあ、次はジャンプの挙動が今は一気に上がってゆっくり落ちるっていう挙動なので、放物線を描くような挙動にしていこうと思います。


アイデア① -JumpPowerアップ！-
じゃあまずはJumpPowerを挙げてみましょう。


ダメですね。
1フレームでめっちゃ高く上がっただけですね。


アイデア② -重力が強すぎた？-
じゃあ重力を弱くしてみます。


ダメですね...。
上に上がったあとゆっくりと下がるだけですね。

じゃあ復習がてら一回ジャンプの仕組みを整理してみましょう。


問題！ジャンプの仕組みはどのようなふうになっていたでしょう？
現在のジャンプと重力の部分のコードを見てみましょう。



        if (IsOnFloor() && Input.IsActionJustPressed("Jump"))
        {
            direction.Y = JumpPower;
        }

        if (IsOnFloor() == false)
        {
            direction.Y -= Grabity;
        }
        else if (IsOnFloor() == true)
        {
            direction.Y = 0;
        }
     
一見正しく書けているように見えますが、これではダメです。
ここでは、ジャンプの入力で direction.Y = JumpPower にした直後に、次の重力処理によって即座に direction.Y を減らしてしまいます。
これにより、ジャンプしたつもりがその直後のフレームで重力に打ち消されるため、思ったようにジャンプができない、つまり「ジャンプ直後に急に落ちる」ように見えるのです。
正しくはこうする必要があります。



  if (IsOnFloor() == false)
        {
            direction.Y -= Grabity;
        }
        else if (IsOnFloor() == true)
        {
            direction.Y = 0;
        }
if (IsOnFloor() && Input.IsActionJustPressed("Jump"))
        {
            direction.Y = JumpPower;
        }
    
なぜこうすることで正しく動くかを解説します。
みなさんご存知だと思いますが、プログラムには実行する順番というものがあります。
コードの上の方から順に下にいくように実行していきます。
つまり、先ほど修正したコードのように順番を入れ替えることで、挙動を変えることができます。
先ほどのコードだと、先に重力を計算することで、ジャンプとして上への力を入れた時に重力の力ですぐに打ち消されるという現象が起こらなくなります。
なので、放物線を描くようにジャンプができるようになります。


無事にジャンプを実装できました。
ジャンプを実装するにあたってですが、ジャンプだけでここまで手こずるとは思ってませんでした。
チュートリアルをやるって大事なことだと実感しました。
私のように早く開発をしたいからってチュートリアルを中途半端なままで開発を始めるよりはちょっと我慢してチュートリアルをやったほうがいいと思います。
私はそのちょっとの我慢ができなかったわけですがね（笑）

~Day5 2025/6/27 -スクラッチは神-~

スクラッチとスクラッチのGODの文字
じゃあ、今日は仕様書の方を進めていこうと思います。
前仕様書をやったのはDay1の時ですね。
じゃあその時何を決めたかちょっと確認してみましょう。


前回の記事

左右移動 / ジャンプと二段ジャンプ / 攻撃は10種類 / 広大なマップを探索する / コイン→武器を買って自分の攻撃力とかをグレードアップ / ストーリーなしのアクションを楽しむモード・ストーリーを楽しむモード

じゃあ今日はストーリーの方を作っていこうと思います。

ストーリーで真っ先に考えるべきことがあります。
「プレイヤーに何をさせるか」です。
ここでゲームのストーリーの核ができる思っても過言ではないです。
私はプレイヤーに何をさせるかを中心に物語を考えているので尚更です。

まあ王道である「大会に出て優勝する」というふうにしましょうか。
こういう横スクロールものの王道ってなんでしょうか。
「誘拐されたお姫様を救う」とか「悪を倒す」でしょうか。
まあ王道なんて気にしなくていいですがね。

この後が重要です。
『なぜプレイヤーはそのようなことをするか』を考える必要があります。
ここを考えるときに重要なことは2つあります。
『動機』と『感情移入』です。

結論から言いますと、プレイヤーを困らせる必要があります。
例えば、賞金10億円の格闘があるとします。
プレイヤーがもしも大金持ちなら、賞金のことよりも怪我などのリスクの方へ目がいき、格闘に自信があるお金持ち以外は出場しないでしょう。
また、出場しても遊ぶ側は感情移入しにくいと思います。
しかしプレイヤーがもしも貧乏人だったらどうでしょうか。
怪我してでも優勝して賞金をゲットしてやる！ってなるはずです。
こういう方が遊ぶ側は感情移入しやすいし、動機としても十分です。
つまり、プレイヤーが不利な状況こそがプレイヤーの設計において重要です。
もちろん、例外は存在します。
例えばスポーツ。
野球をしている高校のコーチになって大会で優勝を目指すとか、世界一を目指すみたいな設定です。
プレイヤーが不利ではなくても大会で優勝という十分な動機があります。
そういう例外に含まれるジャンルのゲーム以外の設計では、基本的にはプレイヤーが不利な状況になるように設計することをお勧めします。
あなたが遊ぶ側ならどういう状況だったら「動かされる」でしょうか。


じゃあ、私のゲームでは『主人公は貧乏人でお金がない。
さらに"食べたいもの"があるけど"お金がない"』というふうにします。


主人公は貧乏でお金と食べたもの（ハンバーガーあたり）を思い浮かべている様子
雑談です。
スクラッチって神ですね。
昨日（Day4）で作ったジャンプのコードあるじゃないですか。
それのコードの元になったのはスクラッチのコードなんですよ。
自分の記憶にあったスクラッチでジャンプを作る方法を元にジャンプのコードを作りました。
やっぱりスクラッチってアニメーションとか3Dがやりにくいだけでかなり自由にできるんだなって感じました。
噂だとスクラッチで物理エンジンを作った人がいるとか聞いたことありますし。
やっぱりすごいですよね。


話を戻します。
プレイヤーが何をするか決定したら、設定はそこから広げてけばいいです。
私の場合だと大会についてとか。

決めたことが「どういう名前で」「なんのために」「どのように」行われてるまたは使うかというものを詳しくしていきましょう。
英語の5W1Hですね。
それぞれに該当する質問を少なくとも1つは考えてそれに答えれば設定はより深く面白くなります。


5W1Hのイラスト
例えばわたしの例だとこのようです。

みなさん、Godotをご存知ですか？GodotはUnity、UE5(Unreal Engine)にならぶ最近注目されてるゲーム開発エンジンの1つです。
今回から、HTMLをマスターした私、ロクペンがゲームを作っていこうと思います。
このシリーズでは私がゲームを作っている時に学んだことや起こったことを言える範囲でみなさんに共有していこうと思うのでよろしく！この記録がみなさんの役に立てたら嬉しいです。
では早速やっていきましょう。


~DAY1 - 2025/6/22（土）~

じゃあ、まずは環境から整えていきましょう！
今回インストールするのは以下の通りです。


Godot.NET4.2.2（当時LTS）
Blender4.4.3（当時最新版）
(Visual Studio Code（マケプレ）: C# dev kit / Godot Tool)
.NETSDKって何？そもそも.NETとは？
.NET（ドットネット）は、Microsoftが提供するアプリ開発のためのプラットフォームです。
C#などの言語で書いたコードをコンピューターで動かすための「実行環境（ランタイム）」や「コンパイラ」、便利な機能がそろったライブラリなどを含んでいます。
Windowsだけでなく、macOSやLinuxでも動作し、Webアプリやゲーム、デスクトップアプリなど、さまざまな用途で使われています。
無料で利用でき、プロ・個人を問わず幅広く使われている開発基盤です。


こちらはとても深く、詳しく解説していると1つの記事にできるレベルなので、後日別の記事にて詳しく解説しようと思います。


.NET SDK8.0をインストールしよう！
インストール方法は以下の通りです。

1. https://dotnet.microsoft.com/ja-jp/downloadを開き、.NET 8.0の方の「Download」を押す。
.NETSDK8.0のインストール方法.NETSDK8.0のインストール方法

私はiMacを使っているので上記した手順なのですが、Windowsだと違うようです。

自分のパソコンがIntelとApple Siliconのどちらかですが、設定を見ればわかります。


IntelはCore i7やi5となっているはずです。

AppleSiliconはM1チップやM2 Proなどとなっているはずです。


コンピューターの種類の書いてあるところへの設定の移動方法 これがないと始まらない！Godotをインストールだ！
早速、Godotをインストールしていきましょう！
手順は以下の通りです。

1. https://godotengine.org/ja/へ飛び、最新版ダウンロードのボタンの下の、「Godot 3や実験的バージョン、または過去のリリースをお探しですか？」の過去のリリースをタップ。
Godotをインストールする手順の写真
2. 下にスクロールし、Godot 4.2の4.2.2-StableをタップGodotをインストールする手順の写真Godotをインストールする手順の写真
3. あなたの機種の列の.NETをタップでダウンロード開始！Godotをインストールする手順の写真

最初に言っておきます。
この時はまだ気づいていなかったのですが、Godot4.4はあまりおすすめはできません。
たくさんの新しいバージョンが出ていて、改善したかもしれませんが、4.4.1では原因不明なバグや仕様が多かったです。
なので私はLTSである4.2.2をダウンロードすることをお勧めします。

まず、Godotをダウンロードして思いました。
「ダウンロード早ッ！」ほんの1分で終わりました。
自分はUnityみたいに30分近くかかると思っていたのですが、意外でした。
そして起動も早いです。
ほんの数十秒で終わっています。
Godotは本当に軽いですね。


Godotって何？最近注目の超軽量ゲーム開発エンジン！
Godot（ゴドー　私は最初ゴードットと思っていた）は無料で使えるオープンソースのゲームエンジンです。
非常に軽量で動作も軽快ですが、だからと言って機能が少ないとか侮ってはいけません。
Godotは2D・3D両方のゲーム開発に対応していて、アニメションから物理エンジン、UIシステム、シェーダーに至るまで、ゲーム制作に必要な機能が一通り揃っています。

また、Godot独自の設計思想として「Node（ノード）とScene（シーン）」の概念があります。
ゲーム内のキャラクターやUIなどは全てNode（ノード）と呼ばれる部品で構成されており、それらを組み合わせたものがSceneになります。
これによって柔軟かつ簡単に再利用性の高いゲーム構造の構築が可能になります。

さらに、Godotには独自のスクリプト言語「GDScript」が搭載！Pythonに似た文法で学習コストが低いのも魅力（私はC#でやっていますがね）。
軽量ながら機能も豊富で初心者からプロまで幅広く活用できるエンジンです。


私がC#での開発を考えた理由は大きく分けて2つあります。

1つは単純にGDScriptでやりにくさを感じたから。
（）[]を書かないコードはちょっと個人的に気持ち悪かったからです。

もう1つはC#はゲーム制作の共通言語だからです。
ゲーム開発エンジンで真っ先に思いつくのはUnity。
UnityはC#でコーディングをします。
また、UneralEngineはC++、CryEngine、SourecEngine、id Tech(id Software)はC++を使ってコーディングします。
このように、ゲーム開発エンジンのほとんどはC系言語を使ってコーディングをします。
つまり、今後どのエンジンに移ってもC系言語をどれか学んでおけばスムーズに移行ができるということです。
まあ、今のところGodot一筋で移行する考えはありません。
今後の保険です。


ゲーム開発するなら避けられない道！Blender
最後にBlenderをインストールしていきましょう！

手順は以下の通りです。

1. https://www.blender.orgを開き、一番初めに出てくる「Download」を押す。
それだけでBlenderはインストールできます。
img alt="Blenderのインストールの手順" src="../img/how-Install-Blender-1.jpg">

こちらはGodotとは違って最新バージョンで大丈夫です。
情報が足りないのではないかと不安なら、ヘッダーの「Download」から入って、下にスクロールして「Go Experimental」と書かれている部分の「Download Blender Experimental」をクリックすれば過去のバージョンがインストールできます。
個人的にはBlender 3.6LTSがお勧めです。
チュートリアルやQ&Aを見たところ最も情報が多いのはこのバージョンだからです。
色々調べたらプロの現場でも現在使っているようです。


Blenderとは？無料で使える最強の3DCGソフト
Blender（ブレンダー） は、無料で使えるオープンソースの3DCG制作ソフトウェアです。
アニメーション制作や3Dモデリング、映像編集、VFX（視覚効果）など、さまざまな用途に対応しており、個人からプロのスタジオまで幅広く利用されています。

Blender の最大の特徴は、「完全無料」なのに高機能であること。
商用利用も自由にできるため、趣味のクリエイターだけでなく、プロの現場でも使われることが増えています。

はっきり言いますと、3Dモデリングはゲーム制作をするにあたって避けては通れない道の一つです。
個人製作者ならほとんどの人がBlenderを使っている印象があります。


注意点はやりこんでキャラクターができてくる中盤〜後半でPCによってはかなり重くなってきます。
私のPCはiMacのM1チップっていう雑魚なので、かなりきついです。

高機能なのでやれることも多く、詳しく解説していると1つの記事にできるレベルなので、後日別の記事にて詳しく解説しようと思います。


環境構築が完了したので、早速それぞれのチュートリアルから始めようと思います！

全ての始まりのチュートリアル
まずはGodotのチュートリアルから行きましょう。
→Godotのチュートリアル

最初の3Dの項目を選んでいる様子
じゃあ、最初の3Dというチュートリアルからやっていきます。


コードを書いている様子-1 コードを書いている様子-2
どのような流れか掴みたいので、コピペをせずに手で全部打っていきます。
実践した方が身につきやすいので自分はコピペをせずにチュートリアルのコードをそのまま移すことを推奨します。


コードを書いている様子-3 コードを書いている様子-4
早速エラーが出ました。


エラーが出ている様子
現在のコンテキストに'MoveAndSlide'という名前は存在しません

簡単にいうと、「MoveAndSlide();なんていう関数はねぇよ！」っていうことです。
チュートリアルには書いてあるのに、なぜでしょうか。
技術的な言い方をすると、Godot 4.xからは「KinematicBody2D」が「CharacterBody2D」になってて、move_and_slide() は velocity 引数が必須になってるらしいです…！チュートリアルが古い説あるな。

/
/
30分後
/
/


ChatGPT先生！助けてください。



え、どした！？何があった！？とりま落ち着いて、詳しく教えて🫨💬


今、Godotのチュートリアルをしてるんだけど、チュートリアルにはMoveAndSlide();って書けって書かれてるのに、エラーが出るのはなんで？


あ〜、なるほど！それなら、Godot 4.4.1でのバージョン特有の問題と、言語や構文の違いが絡んでるかもしれないね。
ちょっと深掘りしてみよう!
🐞 バージョン特有のバグの可能性
Godot 4.x（特に4.4.1）だと、いくつかのAPIの変更や、バグが影響してる可能性もある。
特に「MoveAndSlide()」に関しては、4.xバージョンでのリファクタリングが入ったので、前のバージョンと少し違う部分があるかもしれない。
 例えば：
* MoveAndSlide関数の動作が微妙に変更されたリ、引数が変わったりして、使い方に差が出てる場合がある。

* Godot 4.xでは、CharacterBody2DやCharacterBody3Dの動きに対するコードがかなり更新されてて、チュートリアルが古いバージョンを前提にしている可能性もある。


🧑‍💻 使っている言語と構文の違い
C#の場合 C#では、MoveAndSlide()は引数としてVector2（速度）を渡す必要がある。
もし、構文ミスや引数が足りない場合、エラーが出るよ。
具体的には：
（中略）
4.バージョン特有の不具合があるかも？
  もし、ドキュメント通りに書いてるのにエラーが消えない場合は、 Godot 4.4.1のバージョン特有のバグかもしれないので、GodotのフォーラムやGitHubのissuesをチェックしてみると、同じ問題に直面してる人がいるかも。




...じゃあ、バージョンをチュートリアルに揃えて4.2.2にしてみるよ、ChatGPT先生！


おっ、4.2.2 LTSにダウングレードするの、賢い選択かもね！LTSバージョンは安定してて、バグが少ないから、特に開発中は安心だし、チュートリアル通りに動く可能性が高いよ。

ダウングレードした後、もう一度同じコードを試してみて、エラーが解消されるか確認してみてね。

もしまだ問題が解決しなかったり、バージョン間で不安なところがあれば、気軽に聞いてくれ〜！ サポートするよ！🙌🚀
神の手（Bug Fixer ChatGPT）としてバグ退治手伝うから、なんでも言って！🕹️


ってなわけで、4.2.2にしてきました。
そしたら、エラーも出ずにすんなりと通過できました。


なんかプレイヤーが動きません。
ちょっと探ってみます。

/
/
45分後
/
/
原因わからなかったので諦めます。


ビルドしてもプレイヤーが動かない様子 Blender-チュートリアルで基本操作は完璧！
じゃあ次はBlenderのチュートリアルをやります。

今回私が参考にさせてもらったのはこの動画です。

・【Blender】動物（ひよこ）を作ろう！初心者向けチュートリアルYouTube · サルでもわかるBlender【サルブレ】2024/12/11・
・【初心者歓迎】blenderミニルームの作り方｜入門チュートリアルYouTube · 3D Bibi2024/02/10じゃあ、早速、ひよこの方から作ってきましょう。


ひよこを作ってる様子。
ひよこの入る殻を作っている様子と目を作っている様子、マテリアルを入れている様子、レンダリングしている様子
Blenderの基本操作のほとんどをしたと思います。
皆さんも初めてBlenderをやるという方はこれをみながらやるといいです。
かなりわかりやすかったです。


無事完成しました！お手本とちょっと形は違うけど、これが自分の“味”ってことでむしろオリジナリティ出てて気に入ってます！
試しにシルクハットも被せてみました。
かなり可愛くできました。


完成したひよこの写真とシルクハットを被せた写真
次にミニルームを作っていきましょう。


ベッドの掛け布団を作る時なのですが、物理演算の計算をBlenderにやってもらって作りました。
物理演算と聞いて最初は難しそうだと思ったのですが、意外と簡単でした。
掛け布団になるオブジェクトにCloth（布）という役割、マットレスにコリジョン（衝突するもの）という役割を与えて、アニメーションを実行すれば、Blenderが自動で布の形を計算してくれます。
あとは自分の好みの形状になったところで止めて、シミュレーションの適用（形の固定）をすればいいだけです。
ね。
簡単でしょ。


ミニルームを作ってる様子。
外壁を作っている様子、マットレスを作ってる様子、ベッドの枕を作っている様子、布団の物理演算をやっている様子
ちょっと変な影がありますが、私の中では許容範囲内だったのでOKです。


~締め~

今回はゲーム開発をするためにアプリや.NETSDKをインストールしたり、流れを掴み基本操作を学ぶためにチュートリアルをやりました。
まだチュートリアル段階ですが、とても楽しかったです。
本当は1つの記事に7日分詰め込もうと思ったのですが、記事の長さがとてつもないことになりそうだったので、この1日目の半分をPart0、つまり序章として記事にすることにしました。
次回からいよいよゲームの中身に入っていきます！開発の第一歩、見逃さないでくださいね！
ここまで読んでいただきありがとうございます。
次回もお楽しみに！バイバイ！
Who：誰が大会に参加するか　→ 星中の力自慢や大会で優勝したい人
Why：なんのためにその大会をするか　→ 星の中の最強を決める大会。

What：大会では何を競うか　→ 大会では基本的に戦闘での強さを競うが、大会の会場に向かうまでの、探索力・ギミックを攻略力・謎解き力なども必要。

When：いつ、どのくらいの頻度で開催されるか　→ 毎年初夏から年末にかけて長期的に開催される。

Where：どこでその大会が行われるか　→ 各地に大会の予選や決勝などのための会場があり、プレイヤーはそこをマップの中を探索して探す。

How：どのような形式で行われるか　→ トーナメント形式。
1つ前のエリアの会場でそこの地区の優勝者に勝ったら次の地区で戦える。

このような感じで、5W1Hの各項目に当てはまる質問に答えていくと、最初の自分の考えた紙のように薄かった設定が、さまざまな設定が重なり束ねられることで1つの本のように奥行きが生まれてきます。
この質問をより多く作りそれに応えるほど、本のページ数は増えていき、重く分厚くなり、設定として濃くなっていきます。
詳しい設定ができたら、どのように進むか流れを軽く考えておくといいです。

かなり考えることができたので本日はここまでにしておきましょう。


~Day6 2025/6/28 -念願の二段ジャンプ-~

じゃあ今日は二段ジャンプの方を作ってきましょう。
じゃあジャンプの機構を振り返っていきましょう。



if (IsOnFloor() && Input.IsActionJustPressed("Jump"))
        {
            direction.Y = JumpPower;
        }
OK、なんとなくつかめました。
まずはジャンプ回数を制限するために専用の変数を作っていきます。



private int _jumpLimit = 2;
今回作るのは二段ジャンプなのでジャンプ回数の制限は2回です。


_jumpLimitの"_"ってなんだ！h3>
今作った変数の名前に "_（アンダーバー）"をつけているのには歴とした理由があるので、解説しようと思います。

C#やGodot C#では、**クラスの中で使われる「private（外からアクセスできない）変数」には"_"をつけるスタイルがよく使われます。
これは「この変数は内部用ですよ」という意味です。

よく勘違いされるのですが、_PhysicsProcessや_Readyなどの関数にも"_"がついてますが、定数を意味する"_"とは若干違い、「Godotが内部的に呼び出す特別な関数」という意味です。


ジャンプ回数を制限する変数が書けたので、条件分岐の方を変えていきます。



if ((IsOnFloor() || _jumpLimit > 0) && Input.IsActionJustPressed("Jump"))
  
論理演算子　"||"
タイトルの方で意味は書いてしまいましたが、" || "は『または』という意味の論理演算子です。
高校数学でよく嫌われているやつですね。
この『または』は少なくともどちらか一方がTrueでTrueと返します。
高校数学だと、『少なくともこのどちらか一方で』っていうのが面倒くさいんですよね。
だから対偶を考えるんです。
数学の話になりますが、命題を全て否定したのが対偶です。
例えば、「もし n² が偶数なら、n も偶数である」っていうやつの対偶は全てを否定した 「が奇数ならば、n² も奇数である」というふうですね。
全てをひっくり返したものが対偶です。

脱線してしまったので話を戻します。
" || "は『または』という意味です。
これさえ覚えておけばいいです。


これを元に私の書いた条件式を読み解くとこのようになります。

if （床の上　または　_jumpLimitが0より大きい）且つJumpが押されたら
というふうになります。


では処理の方を書いていきましょう。



if ((IsOnFloor() || _jumpLimit > 0) && Input.IsActionJustPressed("Jump"))
　　{
            direction.Y = JumpPower;
            _jumpLimit -= 1;
        }
  
これだけで二段ジャンプできるようになります。
本当ですよ！実際にやってみせましょうか？


大成功ですね！
二段ジャンプも上手く行ったことだし、明日は攻撃の方を作ろうと思います。


~ 締め~

今回はジャンプの完全版と二段ジャンプが完成しましたね。
また、仕様書を少しですが進めることができました。
仕様書は大切ですよ。
これがないと何を作るか、何をどうするかとかをその場で決める手間がなくなりますから。
なので仕様書はプロジェクトと同時並行してて、若干先に進んでるぐらいの勢いで書いた方がいいです。

話が変わりますが、もともとDay1~Day7までが1つの記事になる予定だったのに3つになってしまいましたね。

次回からBlenderが主役の記事になりますので、お楽しみに!
それでは、バイバイ！
